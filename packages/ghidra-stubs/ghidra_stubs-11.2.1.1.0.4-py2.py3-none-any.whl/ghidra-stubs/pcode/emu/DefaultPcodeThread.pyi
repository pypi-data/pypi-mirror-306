from typing import List
from typing import overload
import ghidra.app.plugin.processors.sleigh
import ghidra.pcode.emu
import ghidra.pcode.exec
import ghidra.pcode.opbehavior
import ghidra.program.model.address
import ghidra.program.model.lang
import ghidra.program.model.listing
import ghidra.program.model.pcode
import java.lang
import java.lang.reflect
import java.util


class DefaultPcodeThread(object, ghidra.pcode.emu.PcodeThread):
    """
    The default implementation of PcodeThread suitable for most applications
 
 
     When emulating on concrete state, consider using ModifiedPcodeThread, so that state
     modifiers from the older Emulator are incorporated. In either case, it may be worthwhile
     to examine existing state modifiers to ensure they are appropriately represented in any abstract
     state. It may be necessary to port them.
 
 
     This class implements the control-flow logic of the target machine, cooperating with the p-code
     program flow implemented by the PcodeExecutor. This implementation exists primarily in
     #beginInstructionOrInject() and #advanceAfterFinished().
    """






    class PcodeEmulationLibrary(ghidra.pcode.exec.AnnotatedPcodeUseropLibrary):




        def __init__(self, __a0: ghidra.pcode.emu.DefaultPcodeThread): ...



        def compose(self, __a0: ghidra.pcode.exec.PcodeUseropLibrary) -> ghidra.pcode.exec.PcodeUseropLibrary: ...

        def emu_exec_decoded(self) -> None: ...

        def emu_injection_err(self) -> None: ...

        def emu_skip_decoded(self) -> None: ...

        def emu_swi(self) -> None: ...

        def equals(self, __a0: object) -> bool: ...

        def getClass(self) -> java.lang.Class: ...

        @staticmethod
        def getOperandType(__a0: java.lang.Class) -> java.lang.reflect.Type: ...

        def getSymbols(self, __a0: ghidra.app.plugin.processors.sleigh.SleighLanguage) -> java.util.Map: ...

        def getUserops(self) -> java.util.Map: ...

        def hashCode(self) -> int: ...

        @staticmethod
        def nil() -> ghidra.pcode.exec.PcodeUseropLibrary: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...






    class PcodeThreadExecutor(ghidra.pcode.exec.PcodeExecutor):




        def __init__(self, __a0: ghidra.pcode.emu.DefaultPcodeThread): ...



        @overload
        def begin(self, __a0: ghidra.pcode.exec.PcodeProgram) -> ghidra.pcode.exec.PcodeFrame: ...

        @overload
        def begin(self, __a0: List[object], __a1: java.util.Map) -> ghidra.pcode.exec.PcodeFrame: ...

        def equals(self, __a0: object) -> bool: ...

        @overload
        def execute(self, __a0: ghidra.pcode.exec.PcodeProgram, __a1: ghidra.pcode.exec.PcodeUseropLibrary) -> ghidra.pcode.exec.PcodeFrame: ...

        @overload
        def execute(self, __a0: List[object], __a1: java.util.Map, __a2: ghidra.pcode.exec.PcodeUseropLibrary) -> ghidra.pcode.exec.PcodeFrame: ...

        def executeBinaryOp(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.opbehavior.BinaryOpBehavior) -> None: ...

        def executeBranch(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.exec.PcodeFrame) -> None: ...

        def executeCall(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.exec.PcodeFrame, __a2: ghidra.pcode.exec.PcodeUseropLibrary) -> None: ...

        def executeCallother(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.exec.PcodeFrame, __a2: ghidra.pcode.exec.PcodeUseropLibrary) -> None: ...

        def executeConditionalBranch(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.exec.PcodeFrame) -> None: ...

        def executeIndirectBranch(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.exec.PcodeFrame) -> None: ...

        def executeIndirectCall(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.exec.PcodeFrame) -> None: ...

        def executeLoad(self, __a0: ghidra.program.model.pcode.PcodeOp) -> None: ...

        def executeReturn(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.exec.PcodeFrame) -> None: ...

        def executeSleigh(self, __a0: unicode) -> None: ...

        def executeStore(self, __a0: ghidra.program.model.pcode.PcodeOp) -> None: ...

        def executeUnaryOp(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.opbehavior.UnaryOpBehavior) -> None: ...

        def finish(self, __a0: ghidra.pcode.exec.PcodeFrame, __a1: ghidra.pcode.exec.PcodeUseropLibrary) -> None: ...

        def getArithmetic(self) -> ghidra.pcode.exec.PcodeArithmetic: ...

        def getClass(self) -> java.lang.Class: ...

        def getLanguage(self) -> ghidra.app.plugin.processors.sleigh.SleighLanguage: ...

        def getReason(self) -> ghidra.pcode.exec.PcodeExecutorStatePiece.Reason: ...

        def getState(self) -> ghidra.pcode.exec.PcodeExecutorState: ...

        def getThread(self) -> ghidra.pcode.emu.DefaultPcodeThread: ...

        def getUseropName(self, __a0: int, __a1: ghidra.pcode.exec.PcodeFrame) -> unicode: ...

        def hashCode(self) -> int: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def skip(self, __a0: ghidra.pcode.exec.PcodeFrame) -> None: ...

        def step(self, __a0: ghidra.pcode.exec.PcodeFrame, __a1: ghidra.pcode.exec.PcodeUseropLibrary) -> None: ...

        def stepOp(self, __a0: ghidra.program.model.pcode.PcodeOp, __a1: ghidra.pcode.exec.PcodeFrame, __a2: ghidra.pcode.exec.PcodeUseropLibrary) -> None: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        @property
        def thread(self) -> ghidra.pcode.emu.DefaultPcodeThread: ...

    def __init__(self, name: unicode, machine: ghidra.pcode.emu.AbstractPcodeMachine):
        """
        Construct a new thread
        @see AbstractPcodeMachine#createThread(String)
        @param name the name of the thread
        @param machine the machine containing the thread
        """
        ...



    def assignContext(self, context: ghidra.program.model.lang.RegisterValue) -> None: ...

    def clearAllInjects(self) -> None: ...

    def clearInject(self, address: ghidra.program.model.address.Address) -> None: ...

    def dropInstruction(self) -> None: ...

    def equals(self, __a0: object) -> bool: ...

    def executeInstruction(self) -> None: ...

    def finishInstruction(self) -> None: ...

    def getArithmetic(self) -> ghidra.pcode.exec.PcodeArithmetic: ...

    def getClass(self) -> java.lang.Class: ...

    def getContext(self) -> ghidra.program.model.lang.RegisterValue: ...

    def getCounter(self) -> ghidra.program.model.address.Address: ...

    def getExecutor(self) -> ghidra.pcode.exec.PcodeExecutor: ...

    def getFrame(self) -> ghidra.pcode.exec.PcodeFrame: ...

    def getInstruction(self) -> ghidra.program.model.listing.Instruction: ...

    def getLanguage(self) -> ghidra.app.plugin.processors.sleigh.SleighLanguage: ...

    def getMachine(self) -> ghidra.pcode.emu.AbstractPcodeMachine: ...

    def getName(self) -> unicode: ...

    def getState(self) -> ghidra.pcode.emu.ThreadPcodeExecutorState: ...

    def getUseropLibrary(self) -> ghidra.pcode.exec.PcodeUseropLibrary: ...

    def hashCode(self) -> int: ...

    def inject(self, address: ghidra.program.model.address.Address, source: unicode) -> None: ...

    def isSuspended(self) -> bool: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def overrideContext(self, context: ghidra.program.model.lang.RegisterValue) -> None: ...

    def overrideContextWithDefault(self) -> None: ...

    def overrideCounter(self, counter: ghidra.program.model.address.Address) -> None: ...

    def reInitialize(self) -> None: ...

    def run(self) -> None: ...

    def setCounter(self, counter: ghidra.program.model.address.Address) -> None: ...

    def setSuspended(self, suspended: bool) -> None: ...

    def skipInstruction(self) -> None: ...

    def skipPcodeOp(self) -> None: ...

    @overload
    def stepInstruction(self) -> None: ...

    @overload
    def stepInstruction(self, __a0: long) -> None: ...

    def stepPatch(self, sleigh: unicode) -> None: ...

    @overload
    def stepPcodeOp(self) -> None: ...

    @overload
    def stepPcodeOp(self, __a0: long) -> None: ...

    def toString(self) -> unicode: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def arithmetic(self) -> ghidra.pcode.exec.PcodeArithmetic: ...

    @property
    def context(self) -> ghidra.program.model.lang.RegisterValue: ...

    @property
    def counter(self) -> ghidra.program.model.address.Address: ...

    @counter.setter
    def counter(self, value: ghidra.program.model.address.Address) -> None: ...

    @property
    def executor(self) -> ghidra.pcode.exec.PcodeExecutor: ...

    @property
    def frame(self) -> ghidra.pcode.exec.PcodeFrame: ...

    @property
    def instruction(self) -> ghidra.program.model.listing.Instruction: ...

    @property
    def language(self) -> ghidra.app.plugin.processors.sleigh.SleighLanguage: ...

    @property
    def machine(self) -> ghidra.pcode.emu.AbstractPcodeMachine: ...

    @property
    def name(self) -> unicode: ...

    @property
    def state(self) -> ghidra.pcode.emu.ThreadPcodeExecutorState: ...

    @property
    def suspended(self) -> bool: ...

    @suspended.setter
    def suspended(self, value: bool) -> None: ...

    @property
    def useropLibrary(self) -> ghidra.pcode.exec.PcodeUseropLibrary: ...