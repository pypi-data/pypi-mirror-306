from typing import overload
import ghidra.app.plugin.processors.sleigh
import ghidra.pcode.emu
import ghidra.pcode.exec
import ghidra.program.model.address
import ghidra.program.model.lang
import ghidra.program.model.listing
import java.lang


class ModifiedPcodeThread(ghidra.pcode.emu.DefaultPcodeThread):
    """
    A p-code thread which incorporates per-architecture state modifiers
 
 
     All machines that include a concrete state piece, i.e., all emulators, should use threads derived
     from this class. This implementation assumes that the modified state can be concretized. This
     doesn't necessarily require the machine to be a concrete emulator, but an abstract machine must
     avoid or handle ConcretionErrors arising from state modifiers.
 
 
     For a complete example of a p-code emulator, see PcodeEmulator.
 
 
     TODO: "State modifiers" are a feature of the older Emulator. They are crudely
     incorporated into threads extended from this abstract class, so that they do not yet need to be
     ported to this emulator.
    """





    def __init__(self, name: unicode, machine: ghidra.pcode.emu.AbstractPcodeMachine):
        """
        Construct a new thread with the given name belonging to the given machine
        @see PcodeMachine#newThread(String)
        @param name the name of the new thread
        @param machine the machine to which the new thread belongs
        """
        ...



    def assignContext(self, context: ghidra.program.model.lang.RegisterValue) -> None: ...

    def clearAllInjects(self) -> None: ...

    def clearInject(self, address: ghidra.program.model.address.Address) -> None: ...

    def dropInstruction(self) -> None: ...

    def equals(self, __a0: object) -> bool: ...

    def executeInstruction(self) -> None: ...

    def finishInstruction(self) -> None: ...

    def getArithmetic(self) -> ghidra.pcode.exec.PcodeArithmetic: ...

    def getClass(self) -> java.lang.Class: ...

    def getContext(self) -> ghidra.program.model.lang.RegisterValue: ...

    def getCounter(self) -> ghidra.program.model.address.Address: ...

    def getExecutor(self) -> ghidra.pcode.exec.PcodeExecutor: ...

    def getFrame(self) -> ghidra.pcode.exec.PcodeFrame: ...

    def getInstruction(self) -> ghidra.program.model.listing.Instruction: ...

    def getLanguage(self) -> ghidra.app.plugin.processors.sleigh.SleighLanguage: ...

    def getMachine(self) -> ghidra.pcode.emu.AbstractPcodeMachine: ...

    def getName(self) -> unicode: ...

    def getState(self) -> ghidra.pcode.emu.ThreadPcodeExecutorState: ...

    def getUseropLibrary(self) -> ghidra.pcode.exec.PcodeUseropLibrary: ...

    def hashCode(self) -> int: ...

    def inject(self, address: ghidra.program.model.address.Address, source: unicode) -> None: ...

    def isSuspended(self) -> bool: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def overrideContext(self, context: ghidra.program.model.lang.RegisterValue) -> None: ...

    def overrideContextWithDefault(self) -> None: ...

    def overrideCounter(self, counter: ghidra.program.model.address.Address) -> None: ...

    def reInitialize(self) -> None: ...

    def run(self) -> None: ...

    def setCounter(self, counter: ghidra.program.model.address.Address) -> None: ...

    def setSuspended(self, suspended: bool) -> None: ...

    def skipInstruction(self) -> None: ...

    def skipPcodeOp(self) -> None: ...

    @overload
    def stepInstruction(self) -> None: ...

    @overload
    def stepInstruction(self, __a0: long) -> None: ...

    def stepPatch(self, sleigh: unicode) -> None: ...

    @overload
    def stepPcodeOp(self) -> None: ...

    @overload
    def stepPcodeOp(self, __a0: long) -> None: ...

    def toString(self) -> unicode: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

