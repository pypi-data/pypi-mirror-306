from typing import List
from typing import overload
import ghidra.program.model.address
import ghidra.program.model.data
import ghidra.program.model.lang
import ghidra.program.model.lang.CompilerSpec
import ghidra.program.model.listing
import ghidra.program.model.pcode
import java.lang
import java.util


class TemporaryCompilerSpec(object, ghidra.program.model.lang.CompilerSpec):








    def applyContextSettings(self, ctx: ghidra.program.model.listing.DefaultProgramContext) -> None: ...

    def doesCDataTypeConversions(self) -> bool: ...

    def encode(self, encoder: ghidra.program.model.pcode.Encoder) -> None: ...

    def equals(self, __a0: object) -> bool: ...

    def findBestCallingConvention(self, params: List[ghidra.program.model.listing.Parameter]) -> ghidra.program.model.lang.PrototypeModel: ...

    def getAddressSpace(self, spaceName: unicode) -> ghidra.program.model.address.AddressSpace: ...

    def getAllModels(self) -> List[ghidra.program.model.lang.PrototypeModel]: ...

    def getCallingConvention(self, name: unicode) -> ghidra.program.model.lang.PrototypeModel: ...

    def getCallingConventions(self) -> List[ghidra.program.model.lang.PrototypeModel]: ...

    def getClass(self) -> java.lang.Class: ...

    def getCompilerSpecDescription(self) -> ghidra.program.model.lang.CompilerSpecDescription: ...

    def getCompilerSpecID(self) -> ghidra.program.model.lang.CompilerSpecID: ...

    def getDataOrganization(self) -> ghidra.program.model.data.DataOrganization: ...

    def getDecompilerOutputLanguage(self) -> ghidra.program.model.lang.DecompilerLanguage: ...

    def getDefaultCallingConvention(self) -> ghidra.program.model.lang.PrototypeModel: ...

    def getLanguage(self) -> ghidra.program.model.lang.Language: ...

    def getPcodeInjectLibrary(self) -> ghidra.program.model.lang.PcodeInjectLibrary: ...

    @overload
    def getProperty(self, key: unicode) -> unicode: ...

    @overload
    def getProperty(self, key: unicode, defaultString: unicode) -> unicode: ...

    def getPropertyAsBoolean(self, key: unicode, defaultBoolean: bool) -> bool: ...

    def getPropertyAsInt(self, key: unicode, defaultInt: int) -> int: ...

    def getPropertyKeys(self) -> java.util.Set: ...

    def getPrototypeEvaluationModel(self, modelType: ghidra.program.model.lang.CompilerSpec.EvaluationModelType) -> ghidra.program.model.lang.PrototypeModel: ...

    def getStackBaseSpace(self) -> ghidra.program.model.address.AddressSpace: ...

    def getStackPointer(self) -> ghidra.program.model.lang.Register: ...

    def getStackSpace(self) -> ghidra.program.model.address.AddressSpace: ...

    def hasProperty(self, key: unicode) -> bool: ...

    def hashCode(self) -> int: ...

    def isEquivalent(self, obj: ghidra.program.model.lang.CompilerSpec) -> bool: ...

    def isGlobal(self, addr: ghidra.program.model.address.Address) -> bool: ...

    def isStackRightJustified(self) -> bool: ...

    @staticmethod
    def isUnknownCallingConvention(__a0: unicode) -> bool: ...

    def matchConvention(self, callingConvention: unicode) -> ghidra.program.model.lang.PrototypeModel: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def stackGrowsNegative(self) -> bool: ...

    def toString(self) -> unicode: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

