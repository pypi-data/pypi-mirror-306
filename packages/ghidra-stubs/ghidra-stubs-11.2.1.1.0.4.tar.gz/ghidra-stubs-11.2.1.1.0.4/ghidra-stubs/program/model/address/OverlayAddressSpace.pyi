from typing import overload
import ghidra.program.model.address
import java.lang


class OverlayAddressSpace(ghidra.program.model.address.AbstractAddressSpace):
    OV_SEPARATER: unicode = u':'



    def __init__(self, baseSpace: ghidra.program.model.address.AddressSpace, unique: int, orderedKey: unicode):
        """
        Construction an overlay address space instance.
        @param baseSpace base overlayed address space
        @param unique unique index/sequence number
        @param orderedKey unique ordered key which should generally match overlay name unless 
         already used (e.g., on a renamed overlay space).  This associated value should not be
         changed for a given address factory instance.
        """
        ...



    def add(self, addr: ghidra.program.model.address.Address, displacement: long) -> ghidra.program.model.address.Address: ...

    @overload
    def addNoWrap(self, addr: ghidra.program.model.address.Address, displacement: long) -> ghidra.program.model.address.Address: ...

    @overload
    def addNoWrap(self, addr: ghidra.program.model.address.GenericAddress, displacement: long) -> ghidra.program.model.address.Address: ...

    def addWrap(self, addr: ghidra.program.model.address.Address, displacement: long) -> ghidra.program.model.address.Address: ...

    def addWrapSpace(self, addr: ghidra.program.model.address.Address, displacement: long) -> ghidra.program.model.address.Address: ...

    @overload
    def compareTo(self, space: ghidra.program.model.address.AddressSpace) -> int: ...

    @overload
    def compareTo(self, __a0: object) -> int: ...

    def contains(self, offset: long) -> bool:
        """
        Determine if the specified offset is contained within a defined region of this overlay space.
        @param offset unsigned address offset
        @return true if contained within defined region otherwise false
        """
        ...

    def equals(self, obj: object) -> bool: ...

    @overload
    def getAddress(self, offset: long) -> ghidra.program.model.address.Address: ...

    @overload
    def getAddress(self, addrString: unicode) -> ghidra.program.model.address.Address: ...

    @overload
    def getAddress(self, offset: long, isAddressableWordOffset: bool) -> ghidra.program.model.address.Address: ...

    @overload
    def getAddress(self, addrString: unicode, caseSensitive: bool) -> ghidra.program.model.address.Address: ...

    def getAddressInThisSpaceOnly(self, offset: long) -> ghidra.program.model.address.Address: ...

    def getAddressableUnitSize(self) -> int: ...

    def getAddressableWordOffset(self, byteOffset: long) -> long: ...

    def getBaseSpaceID(self) -> int:
        """
        @return the ID of the address space underlying this space
        """
        ...

    def getClass(self) -> java.lang.Class: ...

    def getMaxAddress(self) -> ghidra.program.model.address.Address: ...

    def getMinAddress(self) -> ghidra.program.model.address.Address: ...

    def getName(self) -> unicode: ...

    def getOrderedKey(self) -> unicode:
        """
        Get the ordered key assigned to this overlay address space instance  This value is used
         when performing {@link #equals(Object)} and {@link #compareTo(AddressSpace)}
         operations.
         <p>
         If this value does not have its optimal value (i.e., same as address space name), the 
         associated {@link AddressFactory} should report a 
         {@link AddressFactory#hasStaleOverlayCondition() stale overlay condition}.
        @return instance ordered key
        """
        ...

    def getOverlayAddress(self, addr: ghidra.program.model.address.Address) -> ghidra.program.model.address.Address: ...

    def getOverlayAddressSet(self) -> ghidra.program.model.address.AddressSetView:
        """
        Get the {@link AddressSet} which corresponds to overlayed physical region which 
         corresponds to the defined overlay regions within the overlay (i.e., overlay blocks).
        @return defined regions within the overlay.  All addresses are overlay addresses.
        """
        ...

    def getOverlayedSpace(self) -> ghidra.program.model.address.AddressSpace:
        """
        Get the overlayed (i.e., underlying) base space associated with this overlay space.
        @return overlayed base space.
        """
        ...

    def getPhysicalSpace(self) -> ghidra.program.model.address.AddressSpace: ...

    def getPointerSize(self) -> int: ...

    def getSize(self) -> int: ...

    def getSpaceID(self) -> int: ...

    def getTruncatedAddress(self, offset: long, isAddressableWordOffset: bool) -> ghidra.program.model.address.Address: ...

    def getType(self) -> int: ...

    def getUnique(self) -> int:
        """
        Returns the unique id value for this space.
        """
        ...

    def hasMappedRegisters(self) -> bool: ...

    def hasSignedOffset(self) -> bool: ...

    def hashCode(self) -> int: ...

    def isConstantSpace(self) -> bool: ...

    def isExternalSpace(self) -> bool: ...

    def isHashSpace(self) -> bool: ...

    def isLoadedMemorySpace(self) -> bool: ...

    def isMemorySpace(self) -> bool: ...

    def isNonLoadedMemorySpace(self) -> bool: ...

    def isOverlaySpace(self) -> bool: ...

    def isRegisterSpace(self) -> bool: ...

    def isStackSpace(self) -> bool: ...

    def isSuccessor(self, addr1: ghidra.program.model.address.Address, addr2: ghidra.program.model.address.Address) -> bool: ...

    def isUniqueSpace(self) -> bool: ...

    @staticmethod
    def isValidName(__a0: unicode) -> bool: ...

    def isValidRange(self, byteOffset: long, length: long) -> bool: ...

    def isVariableSpace(self) -> bool: ...

    def makeValidOffset(self, offset: long) -> long: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def setHasMappedRegisters(self, hasRegisters: bool) -> None:
        """
        Tag this memory space as having memory mapped registers
        @param hasRegisters true if it has registers, false otherwise
        """
        ...

    def setShowSpaceName(self, b: bool) -> None: ...

    def showSpaceName(self) -> bool: ...

    @overload
    def subtract(self, addr: ghidra.program.model.address.Address, displacement: long) -> ghidra.program.model.address.Address: ...

    @overload
    def subtract(self, addr1: ghidra.program.model.address.Address, addr2: ghidra.program.model.address.Address) -> long: ...

    def subtractNoWrap(self, addr: ghidra.program.model.address.Address, displacement: long) -> ghidra.program.model.address.Address: ...

    def subtractWrap(self, addr: ghidra.program.model.address.Address, displacement: long) -> ghidra.program.model.address.Address: ...

    def subtractWrapSpace(self, addr: ghidra.program.model.address.Address, displacement: long) -> ghidra.program.model.address.Address: ...

    def toString(self) -> unicode: ...

    @overload
    def translateAddress(self, addr: ghidra.program.model.address.Address) -> ghidra.program.model.address.Address:
        """
        If the given address is outside the overlay block, then the address is tranlated to an
         address in the base space with the same offset, otherwise (if the address exists in the
         overlay block), it is returned
        @param addr the address to translate to the base space if it is outside the overlay block
        @return either the given address if it is contained in the overlay memory block or an address
                 in the base space with the same offset as the given address.
        """
        ...

    @overload
    def translateAddress(self, addr: ghidra.program.model.address.Address, forceTranslation: bool) -> ghidra.program.model.address.Address:
        """
        Tranlated an overlay-space address (addr, which may exceed the bounds of the overlay space)
         to an address in the base space with the same offset. If forceTranslation is false and addr
         is contained within the overlay-space the original addr is returned.
        @param addr the address to translate to the base space
        @param forceTranslation if true addr will be translated even if addr falls within the bounds
                    of this overlay-space.
        @return either the given address if it is contained in the overlay memory block or an address
                 in the base space with the same offset as the given address.
        """
        ...

    def truncateAddressableWordOffset(self, wordOffset: long) -> long: ...

    def truncateOffset(self, offset: long) -> long: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def addressableUnitSize(self) -> int: ...

    @property
    def baseSpaceID(self) -> int: ...

    @property
    def constantSpace(self) -> bool: ...

    @property
    def externalSpace(self) -> bool: ...

    @property
    def hashSpace(self) -> bool: ...

    @property
    def loadedMemorySpace(self) -> bool: ...

    @property
    def maxAddress(self) -> ghidra.program.model.address.Address: ...

    @property
    def memorySpace(self) -> bool: ...

    @property
    def minAddress(self) -> ghidra.program.model.address.Address: ...

    @property
    def nonLoadedMemorySpace(self) -> bool: ...

    @property
    def orderedKey(self) -> unicode: ...

    @property
    def overlayAddressSet(self) -> ghidra.program.model.address.AddressSetView: ...

    @property
    def overlaySpace(self) -> bool: ...

    @property
    def overlayedSpace(self) -> ghidra.program.model.address.AddressSpace: ...

    @property
    def physicalSpace(self) -> ghidra.program.model.address.AddressSpace: ...

    @property
    def pointerSize(self) -> int: ...

    @property
    def registerSpace(self) -> bool: ...

    @property
    def size(self) -> int: ...

    @property
    def spaceID(self) -> int: ...

    @property
    def stackSpace(self) -> bool: ...

    @property
    def type(self) -> int: ...

    @property
    def unique(self) -> int: ...

    @property
    def uniqueSpace(self) -> bool: ...

    @property
    def variableSpace(self) -> bool: ...