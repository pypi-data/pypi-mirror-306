from typing import List
from typing import overload
import ghidra.program.model.pcode
import java.lang
import java.util


class PcodeFrame(object):
    """
    The executor's internal counter
 
 
     To distinguish the program counter of a p-code program from the program counter of the machine it
     models, we address p-code ops by "index." When derived from an instruction, the address and index
     together form the "sequence number." Because the executor care's not about the derivation of a
     p-code program, it counts through indices. The frame carries with it the p-code ops comprising
     its current p-code program.
 
 
     A p-code emulator feeds p-code to an executor by decoding one instruction at a time. Thus, the
     "current p-code program" comprises only those ops generated by a single instruction. Or else, it
     is a user-supplied p-code program, e.g., to evaluate a Sleigh expression. The frame completes the
     program by falling-through, i.e., stepping past the final op, or by branching externally, i.e.,
     to a different machine instruction. The emulator must then update its program counter accordingly
     and proceed to the next instruction.
    """





    def __init__(self, __a0: ghidra.program.model.lang.Language, __a1: List[object], __a2: java.util.Map): ...



    def advance(self) -> int:
        """
        Advance the index
        @return the value of the index <em>before</em> it was advanced
        """
        ...

    def branch(self, rel: int) -> None:
        """
        Perform an internal branch, relative to the <em>current op</em>.
 
         <p>
         Because index advances before execution of each op, the index is adjusted by an extra -1.
        @param rel the adjustment to the index
        """
        ...

    def copyCode(self) -> List[ghidra.program.model.pcode.PcodeOp]:
        """
        Copy the frame's code (shallow copy) into a new array
        @return the array of ops
        """
        ...

    def equals(self, __a0: object) -> bool: ...

    def finishAsBranch(self) -> None:
        """
        Complete the p-code program, indicating an external branch
        """
        ...

    def getBranched(self) -> int:
        """
        Get the index of the last (branch) op executed
 
         <p>
         The behavior here is a bit strange for compatibility with
         {@link EmulateInstructionStateModifier}. If the p-code program (likely derived from a machine
         instruction) completed with fall-through, then this will return -1. If it completed on a
         branch, then this will return the index of that branch.
        @return 
        """
        ...

    def getClass(self) -> java.lang.Class: ...

    def getCode(self) -> List[ghidra.program.model.pcode.PcodeOp]:
        """
        Get all the ops in the current p-code program.
        @return the list of ops
        """
        ...

    def getUseropName(self, userop: int) -> unicode:
        """
        Get the name of the userop for the given number
        @param userop the userop number, as encoded in the first operand of {@link PcodeOp#CALLOTHER}
        @return the name of the userop, as expressed in the Sleigh source
        """
        ...

    def getUseropNames(self) -> java.util.Map:
        """
        Get the map of userop numbers to names
        @return the map
        """
        ...

    def hashCode(self) -> int: ...

    def index(self) -> int:
        """
        The index of the <em>next</em> p-code op to be executed
 
         <p>
         If the last p-code op resulted in a branch, this will instead return -1.
        @see #isBranch()
        @see #isFallThrough()
        @see #isFinished()
        @return the index, i.e, p-code "program counter."
        """
        ...

    def isBranch(self) -> bool:
        """
        Check if the p-code program has executed a branch
 
         <p>
         Branches can be internal, i.e., within the current program, or external, i.e., to another
         machine instructions. This refers strictly to the latter.
        @see #isFallThrough()
        @see #isFinished()
        @return true if the program completed with an external branch
        """
        ...

    def isFallThrough(self) -> bool:
        """
        Check if the index has advanced past the end of the p-code program
 
         <p>
         If the index has advanced beyond the program, it implies the program has finished executing.
         In the case of instruction emulation, no branch was encountered. The machine should advance
         to the fall-through instruction.
        @see #isBranch()
        @see #isFinished()
        @return true if the program completed without branching
        """
        ...

    def isFinished(self) -> bool:
        """
        Check if the p-code program is completely executed
        @see #isFallThrough()
        @see #isBranch()
        @return true if execution finished, either in fall-through or an external branch
        """
        ...

    def nextOp(self) -> ghidra.program.model.pcode.PcodeOp:
        """
        Get the op at the current index, and then advance that index
 
         <p>
         This is used in the execution loop to retrieve each op to execute
        @return the op to execute
        """
        ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def resetCount(self) -> int:
        """
        Get and reset the number of p-code ops executed
 
         <p>
         Contrast this to {@link #index()}, which marks the next op to be executed. This counts the
         number of ops executed, which will differ from index when an internal branch is taken.
        @return the count
        """
        ...

    def stepBack(self) -> int:
        """
        Step the index back one
        @return the value of the index <em>before</em> it was stepped back
        """
        ...

    def toString(self) -> unicode: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def branched(self) -> int: ...

    @property
    def code(self) -> List[object]: ...

    @property
    def fallThrough(self) -> bool: ...

    @property
    def finished(self) -> bool: ...

    @property
    def useropNames(self) -> java.util.Map: ...