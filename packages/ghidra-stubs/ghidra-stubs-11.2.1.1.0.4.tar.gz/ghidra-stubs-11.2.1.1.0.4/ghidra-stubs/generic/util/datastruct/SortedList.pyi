from typing import Iterator
from typing import List
from typing import overload
import ghidra.generic.util.datastruct
import java.lang
import java.util
import java.util.function


class SortedList(ghidra.generic.util.datastruct.ValueSortedMap.LesserList, object):
    """
    An interface for sorted lists

 
     This might be better described as a NavigableMultiset; however, I wish for the elements to be
     retrievable by index, though insertion and mutation is not permitted by index. This implies that
     though unordered, the underlying implementation has sorted the elements in some way and wishes to
     expose that ordering to its clients.
    """







    def __iter__(self): ...

    def ceilingIndex(self, __a0: object) -> int: ...

    def contains(self, __a0: object) -> bool: ...

    def equals(self, __a0: object) -> bool: ...

    def floorIndex(self, __a0: object) -> int: ...

    def forEach(self, __a0: java.util.function.Consumer) -> None: ...

    def get(self, __a0: int) -> object: ...

    def getClass(self) -> java.lang.Class: ...

    def hashCode(self) -> int: ...

    def higherIndex(self, __a0: object) -> int: ...

    def indexOf(self, __a0: object) -> int: ...

    def isEmpty(self) -> bool: ...

    def iterator(self) -> java.util.Iterator: ...

    def listIterator(self, __a0: int) -> java.util.ListIterator: ...

    def lowerIndex(self, __a0: object) -> int: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def poll(self) -> object: ...

    def remove(self, __a0: object) -> bool: ...

    def removeAll(self, __a0: java.util.Collection) -> bool: ...

    def size(self) -> int: ...

    def spliterator(self) -> java.util.Spliterator: ...

    def toList(self) -> List[object]: ...

    def toString(self) -> unicode: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def empty(self) -> bool: ...