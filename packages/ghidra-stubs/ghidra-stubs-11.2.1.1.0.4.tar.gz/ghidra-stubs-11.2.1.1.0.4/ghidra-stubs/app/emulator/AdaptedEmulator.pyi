from typing import overload
import ghidra.app.emulator
import ghidra.app.plugin.processors.sleigh
import ghidra.pcode.emulate
import ghidra.pcode.exec
import ghidra.pcode.memstate
import ghidra.program.model.address
import ghidra.program.model.lang
import ghidra.util.task
import java.lang
import java.lang.reflect
import java.util


class AdaptedEmulator(object, ghidra.app.emulator.Emulator):
    """
    An implementation of Emulator that wraps the newer PcodeEmulator
 
 
     This is a transitional utility only. It is currently used only by the pcode tests until that is
     ported to use the new PcodeEmulator directly. New use cases based on p-code emulation
     should use the PcodeEmulator directly. Older use cases still being actively maintained
     should begin work porting to PcodeEmulator. Old use cases without active maintenance may
     try this wrapper, but may have to remain using DefaultEmulator. At a minimum, to update
     such old use cases, `new Emulator(...)` must be replaced by `new DefaultEmulator(...)`.
    """






    class AdaptedPcodeUseropLibrary(ghidra.pcode.exec.AnnotatedPcodeUseropLibrary):




        def __init__(self, __a0: ghidra.app.emulator.AdaptedEmulator): ...



        def __addr_cb(self) -> None: ...

        def compose(self, __a0: ghidra.pcode.exec.PcodeUseropLibrary) -> ghidra.pcode.exec.PcodeUseropLibrary: ...

        def equals(self, __a0: object) -> bool: ...

        def getClass(self) -> java.lang.Class: ...

        @staticmethod
        def getOperandType(__a0: java.lang.Class) -> java.lang.reflect.Type: ...

        def getSymbols(self, __a0: ghidra.app.plugin.processors.sleigh.SleighLanguage) -> java.util.Map: ...

        def getUserops(self) -> java.util.Map: ...

        def hashCode(self) -> int: ...

        @staticmethod
        def nil() -> ghidra.pcode.exec.PcodeUseropLibrary: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...



    def __init__(self, config: ghidra.app.emulator.EmulatorConfiguration): ...



    def addMemoryAccessFilter(self, filter: ghidra.app.emulator.MemoryAccessFilter) -> None: ...

    def dispose(self) -> None: ...

    def equals(self, __a0: object) -> bool: ...

    def executeInstruction(self, stopAtBreakpoint: bool, monitor: ghidra.util.task.TaskMonitor) -> None: ...

    def getBreakTable(self) -> ghidra.pcode.emulate.BreakTableCallBack: ...

    def getClass(self) -> java.lang.Class: ...

    def getContextRegisterValue(self) -> ghidra.program.model.lang.RegisterValue: ...

    def getEmulateExecutionState(self) -> ghidra.pcode.emulate.EmulateExecutionState: ...

    def getExecuteAddress(self) -> ghidra.program.model.address.Address: ...

    def getFilteredMemState(self) -> ghidra.app.emulator.FilteredMemoryState: ...

    def getHalt(self) -> bool: ...

    def getLastExecuteAddress(self) -> ghidra.program.model.address.Address: ...

    def getMemState(self) -> ghidra.pcode.memstate.MemoryState: ...

    def getPC(self) -> long: ...

    def getPCRegisterName(self) -> unicode: ...

    def hashCode(self) -> int: ...

    def isAtBreakpoint(self) -> bool: ...

    def isExecuting(self) -> bool: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def setContextRegisterValue(self, regValue: ghidra.program.model.lang.RegisterValue) -> None: ...

    def setExecuteAddress(self, addressableWordOffset: long) -> None: ...

    def setHalt(self, halt: bool) -> None: ...

    def toString(self) -> unicode: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def PC(self) -> long: ...

    @property
    def PCRegisterName(self) -> unicode: ...

    @property
    def atBreakpoint(self) -> bool: ...

    @property
    def breakTable(self) -> ghidra.pcode.emulate.BreakTableCallBack: ...

    @property
    def contextRegisterValue(self) -> ghidra.program.model.lang.RegisterValue: ...

    @contextRegisterValue.setter
    def contextRegisterValue(self, value: ghidra.program.model.lang.RegisterValue) -> None: ...

    @property
    def emulateExecutionState(self) -> ghidra.pcode.emulate.EmulateExecutionState: ...

    @property
    def executeAddress(self) -> ghidra.program.model.address.Address: ...

    @property
    def executing(self) -> bool: ...

    @property
    def filteredMemState(self) -> ghidra.app.emulator.FilteredMemoryState: ...

    @property
    def halt(self) -> bool: ...

    @halt.setter
    def halt(self, value: bool) -> None: ...

    @property
    def lastExecuteAddress(self) -> ghidra.program.model.address.Address: ...

    @property
    def memState(self) -> ghidra.pcode.memstate.MemoryState: ...