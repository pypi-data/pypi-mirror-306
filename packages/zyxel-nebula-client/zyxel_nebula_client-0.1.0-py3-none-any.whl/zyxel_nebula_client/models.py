# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2024-11-03T08:11:49+00:00

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import List, Optional, Union


class APClientAttributesReq(Enum):
    mac_address = 'mac_address'
    ipv4 = 'ipv4'
    last_seen = 'last_seen'
    connected_device_id = 'connected_device_id'
    first_seen = 'first_seen'
    description = 'description'
    os_hostname = 'os_hostname'
    manufacturer = 'manufacturer'
    ssid = 'ssid'
    wifi_sta = 'wifi_sta'


class APClientAttributesReqV2(Enum):
    mac_address = 'mac_address'
    ipv4 = 'ipv4'
    last_seen = 'last_seen'
    connected_device_id = 'connected_device_id'
    first_seen = 'first_seen'
    description = 'description'
    os_hostname = 'os_hostname'
    manufacturer = 'manufacturer'
    ssid = 'ssid'
    wifi_sta = 'wifi_sta'
    user = 'user'
    upload = 'upload'
    download = 'download'


@dataclass
class APPortPhyStatus:
    port: str
    linkSpeed: Optional[str]


@dataclass
class CableTestPortChannelResult:
    channel: str
    pairStatus: str
    pairLength: str
    pairDistanceToFault: str


@dataclass
class CableTestPortResult:
    port: int
    results: List[CableTestPortChannelResult]


@dataclass
class CableTestReq:
    ports: List[int]


@dataclass
class CableTestResp:
    ports: List[CableTestPortResult]


class ChassisidSubtype(Enum):
    CHASSIS_COMPONENT = 'CHASSIS_COMPONENT'
    INTERFACE_ALIAS = 'INTERFACE_ALIAS'
    PORT_COMPONENT = 'PORT_COMPONENT'
    MAC_ADDRESS = 'MAC_ADDRESS'
    NETWORK_ADDRESS = 'NETWORK_ADDRESS'
    INTERFACE_NAME = 'INTERFACE_NAME'
    LOCAL = 'LOCAL'


@dataclass
class ClientAccessVPNStatus:
    username: str
    hostname: str
    publicIPv4: str
    asssignedIPv4: str


class ClientAttributesReq(Enum):
    mac_address = 'mac_address'
    ipv4 = 'ipv4'
    vlan = 'vlan'
    last_seen = 'last_seen'
    connected_device_id = 'connected_device_id'
    status = 'status'
    first_seen = 'first_seen'
    description = 'description'
    os_hostname = 'os_hostname'
    manufacturer = 'manufacturer'


class ClientPeriod(Enum):
    field_2h = '2h'
    field_1d = '1d'
    field_7d = '7d'
    field_30d = '30d'


@dataclass
class Connectivity:
    begin_time: int
    end_time: int
    status: str


@dataclass
class ConnectivityReq:
    period: Optional[ClientPeriod]


class Status(Enum):
    integer_523 = 523


class Message(Enum):
    Device_Offline = 'Device Offline'


@dataclass
class DeviceOfflineResponse:
    body: Optional[str]
    status: Status = 523
    message: Message = Message.Device_Offline


class DeviceType(Enum):
    AP = 'AP'
    SW = 'SW'
    GW = 'GW'
    FIREWALL = 'FIREWALL'
    WWAN = 'WWAN'
    SCR = 'SCR'
    GWH = 'GWH'
    ACCY = 'ACCY'


@dataclass
class EventLogsReq:
    startTimestamp: int
    endTimestamp: int


class FirmwareStatus(Enum):
    N_A = 'N/A'
    UP_TO_DATE = 'UP_TO_DATE'
    NOT_UP_TO_DATE = 'NOT_UP_TO_DATE'
    DEDICATED = 'DEDICATED'


class GWClientAttributesReq(Enum):
    mac_address = 'mac_address'
    ipv4 = 'ipv4'
    last_seen = 'last_seen'
    connected_device_id = 'connected_device_id'
    first_seen = 'first_seen'
    description = 'description'
    os_hostname = 'os_hostname'
    manufacturer = 'manufacturer'
    interface = 'interface'


@dataclass
class GWClientReq:
    period: Optional[ClientPeriod]
    featrues: List[GWClientAttributesReq]


@dataclass
class GWEventLogEntry:
    timestamp: Optional[int] = None
    category: Optional[str] = None
    devId: Optional[str] = None
    mac: Optional[str] = None
    message: Optional[str] = None
    srcIpv4: Optional[str] = None
    srcPort: Optional[int] = None
    dstIpv4: Optional[str] = None
    dstPort: Optional[int] = None


@dataclass
class GWPortPhyStatus:
    portNumber: str
    portGroup: Optional[str]
    linkSpeed: Optional[str]


@dataclass
class GWTrafficUsage:
    interface: str
    uplinkTxUsage: int
    uplinkRxUage: int


@dataclass
class GenericClientReq:
    period: Optional[ClientPeriod]
    featrues: List[ClientAttributesReq]


@dataclass
class GenericResp:
    status: int
    message: Optional[str]


@dataclass
class Group:
    name: str
    groupId: str


class IPv4Type(Enum):
    STATIC = 'STATIC'
    DHCP = 'DHCP'


class KeyField(Enum):
    macAddress = 'macAddress'
    ipv4Address = 'ipv4Address'
    interface = 'interface'
    vlan = 'vlan'


@dataclass
class LLDPNeighbor:
    lldpRemLocalPortNum: str
    lldpRemPortId: Optional[str]
    lldpRemPortDesc: Optional[str]
    lldpRemSysName: Optional[str]
    lldpRemChassisId: Optional[str]
    lldpRemChassisIdSubtype: Optional[ChassisidSubtype]


@dataclass
class OSHostname:
    os: Optional[str]
    hostname: Optional[str]


@dataclass
class OneToOneInboundConnection:
    enabled: Optional[bool]
    protocol: Optional[int]
    port: List[str]
    remote: List[str]


class OnlineOffline(Enum):
    ONLINE = 'ONLINE'
    OFFLINE = 'OFFLINE'


@dataclass
class OrgLicenseOverview:
    NCCTrialEndAt: Optional[str]
    NCCExpiredAt: Optional[str]


class OrgMode(Enum):
    PRO = 'PRO'
    PLUS = 'PLUS'
    TRIAL = 'TRIAL'
    BASE = 'BASE'
    HAAS = 'HAAS'
    POSTPAY = 'POSTPAY'


@dataclass
class PingReq:
    target: str
    token: Optional[str] = None


@dataclass
class PingResult:
    seq: int
    loss: bool
    timestamp: int
    elapsedTime: int


@dataclass
class PortPOEUsage:
    portNum: int
    enabled: bool
    usage: float


@dataclass
class RemoteAPVPNStatus:
    devId: str
    uptime: int
    status: Optional[str]
    lastHeartbeat: Optional[int]


@dataclass
class SSIDSettingConfig:
    id: int
    wpaKey: str


@dataclass
class SWClient:
    macAddress: str
    vlan: int
    lldp: Optional[str]
    ipv4Address: Optional[str] = None
    lastSeen: Optional[int] = None
    connectedTo: Optional[str] = None
    connectedPort: Optional[str] = None
    firstSeen: Optional[int] = None
    description: Optional[str] = None
    manufacturer: Optional[str] = None


class SWClientAttributesReq(Enum):
    mac_address = 'mac_address'
    ipv4 = 'ipv4'
    last_seen = 'last_seen'
    connected_device_id = 'connected_device_id'
    connected_port = 'connected_port'
    first_seen = 'first_seen'
    description = 'description'
    manufacturer = 'manufacturer'
    vlan = 'vlan'
    lldp_info = 'lldp_info'


@dataclass
class SWClientReq:
    period: Optional[ClientPeriod]
    featrues: List[SWClientAttributesReq]


@dataclass
class SWClients:
    KeyFields: List[KeyField]
    data: Optional[List[SWClient]]


@dataclass
class SWEventLogEntry:
    timestamp: int
    category: str
    devId: str
    mac: str
    message: str
    priority: str
    tag: str


@dataclass
class SWL2MACEntry:
    macAddress: str
    vlan: int
    portNum: int


@dataclass
class SWPOEStatus:
    budget: float
    currentUsage: float
    ports: List[PortPOEUsage]


@dataclass
class SWPortPhyStatus:
    portNum: int
    linkSpeed: str


@dataclass
class SWPortUplink:
    portNum: int


@dataclass
class SWTrafficUsage:
    devId: str
    uplinkTxUsage: int
    uplinkRxUage: int


@dataclass
class Site:
    name: str
    siteId: str
    timeZone: str
    deviceCount: int


class Status1(Enum):
    integer_404 = 404


class Message1(Enum):
    siteId_not_Found = 'siteId not Found'
    devId_not_Found = 'devId not Found'


@dataclass
class SiteDeviceNotFoundResponse:
    body: Optional[str]
    message: Message1
    status: Status1 = 404


class Message2(Enum):
    siteId_not_Found = 'siteId not Found'


@dataclass
class SiteNotFoundResponse:
    body: Optional[str]
    status: Status1 = 404
    message: Message2 = Message2.siteId_not_Found


@dataclass
class SwitchPortSetting:
    portNum: int
    enabled: bool
    trunk: bool
    portVid: int
    allowedVLAN: List[str]
    hasPse: bool
    pseEnabled: bool


@dataclass
class SwitchPortSettingConfig:
    portNum: int
    enabled: bool
    trunk: bool
    portVid: int
    allowedVLAN: List[str]
    pseEnabled: Optional[bool]


@dataclass
class SystemStatus:
    cpuUsage: Optional[float]
    memUsage: Optional[float]
    sessions: Optional[int]


class TrafficUsagePeriod(Enum):
    field_2h = '2h'
    field_1d = '1d'
    field_7d = '7d'


@dataclass
class VPNTunnelStatus:
    uptime: int
    status: Optional[str]
    lastHeartbeat: Optional[int]


@dataclass
class ValidationError:
    loc: List[Union[str, int]]
    msg: str
    type: str


@dataclass
class VirtualServerEntry:
    enabled: bool
    description: str
    interface: str
    protocol: int
    publicIPv4: Optional[str]
    publicPorts: List[str]
    serverIPv4: str
    serverPorts: List[str]
    allowedRemote: List[str]


class WANIPv4Type(Enum):
    STATIC = 'STATIC'
    DHCP = 'DHCP'
    PPPOE = 'PPPOE'
    PPPOE_WITH_STATIC_IP = 'PPPOE_WITH_STATIC_IP'


@dataclass
class WWANStatus:
    ipv4Address: str
    imei: Optional[str]
    iccid: Optional[str]
    rsrp: Optional[int]


class WiFiBand(Enum):
    band24 = 'band24'
    band50 = 'band50'
    band60 = 'band60'


class WiFiCaptivePortal(Enum):
    DISABLED = 'DISABLED'
    CLICK_TO_CONTINUE = 'CLICK_TO_CONTINUE'
    CAPTIVE_PORTAL_CLOUD = 'CAPTIVE_PORTAL_CLOUD'
    CAPTIVE_PORTAL_RADIUS = 'CAPTIVE_PORTAL_RADIUS'
    SNS_FACEBOOK = 'SNS_FACEBOOK'
    SNS_FACEBOOK_WIFI = 'SNS_FACEBOOK_WIFI'
    CAPTIVE_PORTAL_VOUCHER = 'CAPTIVE_PORTAL_VOUCHER'


class WiFiSecurityType(Enum):
    OPEN = 'OPEN'
    OPEN_ENHANCED = 'OPEN_ENHANCED'
    WPA2_PSK = 'WPA2_PSK'
    WPA2_ENT_CLOUDAUTH = 'WPA2_ENT_CLOUDAUTH'
    WPA2_ENT_RADIUS = 'WPA2_ENT_RADIUS'
    WPA3_PSK = 'WPA3_PSK'
    WPA3_ENT_CLOUDAUTH = 'WPA3_ENT_CLOUDAUTH'
    WPA3_ENT_RADIUS = 'WPA3_ENT_RADIUS'


@dataclass
class APClientInfo:
    status: Optional[OnlineOffline]
    vlan: Optional[int]
    signal: Optional[int]
    band: Optional[WiFiBand]
    channel: Optional[int]


@dataclass
class APClientReq:
    period: Optional[ClientPeriod]
    featrues: List[APClientAttributesReqV2]


@dataclass
class APClientSSID:
    name: Optional[str]
    security: Optional[WiFiSecurityType]


@dataclass
class APClientV2:
    macAddress: str
    ssid: Optional[APClientSSID]
    wifiStation: Optional[APClientInfo]
    ipv4Address: Optional[str] = None
    lastSeen: Optional[int] = None
    connectedTo: Optional[str] = None
    firstSeen: Optional[int] = None
    description: Optional[str] = None
    osHostname: Optional[OSHostname] = None
    manufacturer: Optional[str] = None
    user: Optional[str] = None
    upload: Optional[float] = None
    download: Optional[float] = None


@dataclass
class APClients:
    KeyFields: List[KeyField]
    data: Optional[List[APClientV2]]


@dataclass
class DevInterfaceIPStatus:
    interface: str
    ipv4Type: Optional[IPv4Type]
    ipv4Address: Optional[str]
    ipv4Netmask: Optional[str]
    ipv4Gateway: Optional[str]
    DNSServers: List[Optional[str]]
    vlan: Optional[int] = None


@dataclass
class Device:
    devId: str
    name: str
    mac: str
    sn: str
    model: str
    type: DeviceType


@dataclass
class DeviceFirmwareStatus:
    devId: str
    currentVersion: Optional[str]
    latestVersion: Optional[str]
    status: Optional[FirmwareStatus]
    lastUpgradeTime: Optional[str]


@dataclass
class DeviceOnlineStatus:
    devId: str
    currentStatus: OnlineOffline


@dataclass
class GWClient:
    macAddress: str
    ipv4Address: str
    interface: str
    lastSeen: Optional[int] = None
    connectedTo: Optional[str] = None
    firstSeen: Optional[int] = None
    description: Optional[str] = None
    osHostname: Optional[OSHostname] = None
    manufacturer: Optional[str] = None


@dataclass
class GWClients:
    KeyFields: List[KeyField]
    data: Optional[List[GWClient]]


@dataclass
class GWLANInterfaceStatus:
    id: Optional[str]
    enabled: Optional[bool]
    portGroupId: str
    interface: str
    ipv4Type: IPv4Type
    ipv4Address: str
    ipv4Netmask: str
    guestZone: bool


@dataclass
class GWWANInterfaceStatus:
    id: Optional[str]
    enabled: Optional[bool]
    portGroupId: Optional[str]
    interface: str
    ipv4Type: WANIPv4Type
    ipv4Address: Optional[str]
    ipv4Netmask: Optional[str]
    ipv4Gateway: Optional[str]
    DNSServers: List[Optional[str]]
    vlan: Optional[int] = None


@dataclass
class GenericClient:
    macAddress: str
    status: OnlineOffline
    ipv4Address: Optional[str] = None
    vlan: Optional[int] = None
    lastSeen: Optional[int] = None
    connectedTo: Optional[str] = None
    firstSeen: Optional[int] = None
    description: Optional[str] = None
    osHostname: Optional[OSHostname] = None
    manufacturer: Optional[str] = None


@dataclass
class GenericClients:
    KeyFields: List[KeyField]
    data: Optional[List[GenericClient]]


@dataclass
class HTTPValidationError:
    detail: Optional[List[ValidationError]] = None


@dataclass
class NonNebulaGatewayVPNStatus:
    peer: str
    subnets: List[str]
    tunnel: List[Optional[VPNTunnelStatus]]


@dataclass
class OneToOneEntry:
    enabled: bool
    name: Optional[str]
    interface: str
    publicIPv4: str
    privateIPv4: str
    inbound: List[OneToOneInboundConnection]


@dataclass
class Org:
    name: str
    orgId: str
    mode: OrgMode
    licenseOverview: OrgLicenseOverview
    prevMode: Optional[OrgMode] = None
    mspId: Optional[str] = None
    notes: Optional[str] = None


@dataclass
class OrgBaseInfo:
    name: str
    orgId: str
    mode: OrgMode


@dataclass
class PingResp:
    isDone: bool
    token: Optional[str] = None
    results: Optional[List[PingResult]] = None


@dataclass
class SSIDSetting:
    name: str
    enabled: bool
    security: WiFiSecurityType
    band: List[WiFiBand]
    visibility: bool
    vlan: int
    wpaKey: Optional[str]
    captivePortal: WiFiCaptivePortal


@dataclass
class Site2SiteVPNStatus:
    siteId: str
    subnets: Optional[List[str]]
    tunnel: List[Optional[VPNTunnelStatus]]


@dataclass
class SiteVPNStatus:
    sites: Optional[List[Site2SiteVPNStatus]] = None
    gateways: Optional[List[NonNebulaGatewayVPNStatus]] = None
    remoteAps: Optional[List[RemoteAPVPNStatus]] = None
    cleints: Optional[List[ClientAccessVPNStatus]] = None


@dataclass
class SitesDevices:
    siteId: Optional[str]
    devices: List[Optional[Device]]


@dataclass
class APClient:
    macAddress: str
    ssid: Optional[APClientSSID]
    wifiStation: Optional[APClientInfo]
    ipv4Address: Optional[str] = None
    lastSeen: Optional[int] = None
    connectedTo: Optional[str] = None
    firstSeen: Optional[int] = None
    description: Optional[str] = None
    osHostname: Optional[OSHostname] = None
    manufacturer: Optional[str] = None


@dataclass
class GWInterfaceSetting:
    wan: List[GWWANInterfaceStatus]
    lan: List[GWLANInterfaceStatus]


@dataclass
class NATSetting:
    oneToOne: List[OneToOneEntry]
    virtualServer: List[VirtualServerEntry]
