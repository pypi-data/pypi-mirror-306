%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{greenland\sphinxhyphen{}base}
\date{Oct 04, 2024}
\release{0.0.6}
\author{M E Leypold}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Module \sphinxtitleref{greenland.base.enums}}
\label{\detokenize{enums:module-greenland-base-enums}}\label{\detokenize{enums::doc}}\index{module@\spxentry{module}!greenland.base.enums@\spxentry{greenland.base.enums}}\index{greenland.base.enums@\spxentry{greenland.base.enums}!module@\spxentry{module}}\phantomsection\label{\detokenize{enums:module-greenland.base.enums}}
\sphinxAtStartPar
Provides an enumeration (Enum) type as python objects.

\sphinxAtStartPar
The way programming languages handle “enums” — a small set of
discrete objects belonging together, like primary colors or days of
the week \textendash{} is often influenced by the capabilities of the programming
language whithin which such a facility exists. Very often the emphasis
is on providing names (identifiers) for integers as if the central
semantics of e.g. a weekday is it being a number. Enums in C certainly
work like this.

\sphinxAtStartPar
One unfortunate consequence of these types of design decisions is,
that it is difficult to express in type annotations that a certain
parameter should only take members of a specific enum. The conclusion
we must draw is, that it is desirable that enum types correspond to
classes and that the enum members are instances of those classes, so
it is possible to express the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{day}\PYG{p}{:} \PYG{n}{Weekday}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The built\sphinxhyphen{}in enums of \sphinxstyleemphasis{Python} work like this already.  The author of
this package also became (admittedly) aware of the built\sphinxhyphen{}in enums too
late, so went down a slightly different (but possibly simpler) path.

\sphinxAtStartPar
This package provides enums as a type where the enumeration type is a
class (almost like any other) which only has a finite, explicitely
specified number of instances (the members) and where the enum member
can be enriched with almost any kind of additional behaviour.


\section{Constructing enum types with \sphinxstyleliteralintitle{\sphinxupquote{Enum}}}
\label{\detokenize{enums:constructing-enum-types-with-enum}}\index{Enum (class in greenland.base.enums)@\spxentry{Enum}\spxextra{class in greenland.base.enums}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{enums:greenland.base.enums.Enum}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{Enum}}}{\sphinxparam{\DUrole{n}{name\_or\_ord}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{str\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ord}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The super class of all enum types (= classes).

\sphinxAtStartPar
Enum types are created by deriving from {\hyperref[\detokenize{enums:greenland.base.enums.Enum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Enum}}}}}. Members
are added by calling the constructor and assigning to an
identifier in the same namespace as the class definition before
calling \sphinxcode{\sphinxupquote{finalize()}}.

\sphinxAtStartPar
After \sphinxcode{\sphinxupquote{finalize()}}, the constructor will just either
return a previously existing member of the enum type or raise a
\sphinxcode{\sphinxupquote{ParseError}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name\_or\_ord}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Before finalizing the enum type only the name of
the enum member — a \sphinxcode{\sphinxupquote{str}} \textendash{} is allowed here. After
finalization both a \sphinxcode{\sphinxupquote{str}} and a \sphinxcode{\sphinxupquote{int}} here are allowed and
do not construct a new member, but rather retrieve a member of
the give \sphinxstyleemphasis{name} or \sphinxstyleemphasis{ord} respectively. A
\sphinxcode{\sphinxupquote{ParseError}} will be raised if such a member does
not exist.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Before finalizing the the enum type an optional \sphinxcode{\sphinxupquote{ord}}
integer for the member. After finalization this argument must
not be given.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\sphinxSetupCaptionForVerbatim{Define enum type and members:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{greenland}\PYG{n+nn}{.}\PYG{n+nn}{base}\PYG{n+nn}{.}\PYG{n+nn}{enums} \PYG{k+kn}{import} \PYG{n}{Enum}


\PYG{k}{class} \PYG{n+nc}{Direction}\PYG{p}{(}\PYG{n}{Enum}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}


\PYG{n}{NORTH}  \PYG{o}{=} \PYG{n}{Direction}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NORTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{EAST} \PYG{o}{=} \PYG{n}{Direction}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EAST}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{SOUTH} \PYG{o}{=} \PYG{n}{Direction}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SOUTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{WEST} \PYG{o}{=} \PYG{n}{Direction}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{WEST}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{Direction}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{finalize()}} will actually do two things:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Lock the type so that further calls to the constructor result either
in retrieval of an already defined member or in raising a
\sphinxcode{\sphinxupquote{ParseError}} if no such member exists.

\item {} 
\sphinxAtStartPar
Check if all members have been bound to names in the same namespace
where the enum class has been defined.

\end{itemize}
\sphinxSetupCaptionForVerbatim{Behavior after finalization:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{Direction}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SOUTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{n}{SOUTH}

\PYG{k}{with} \PYG{n}{pytest}\PYG{o}{.}\PYG{n}{raises}\PYG{p}{(}\PYG{n+ne}{AssertionError}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{Direction}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FOO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Typically enums are global types. I cannot currently see (except for
testing purposes) much of an application for defining an enum in a
local namespace.

\sphinxAtStartPar
Regardless, if one desires to do so, this is possible, but
\sphinxcode{\sphinxupquote{finalize()}} needs to be called with \sphinxcode{\sphinxupquote{%
\PYG{n+nb}{locals}\PYG{p}{(}\PYG{p}{)}%
}}:
\sphinxSetupCaptionForVerbatim{Local enum definition:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Turn}\PYG{p}{(}\PYG{n}{Enum}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}

\PYG{n}{LEFT} \PYG{o}{=} \PYG{n}{Turn}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEFT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{RIGHT} \PYG{o}{=} \PYG{n}{Turn}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RIGHT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{Turn}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{n+nb}{locals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Membership}
\label{\detokenize{enums:membership}}
\sphinxAtStartPar
Membership (if a value is a member of an enum) can be tested using the
operator \sphinxstyleemphasis{in} or using \sphinxstyleemphasis{isinstance}.
\sphinxSetupCaptionForVerbatim{Testing membership:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{SOUTH} \PYG{o+ow}{in} \PYG{n}{Direction}
\PYG{k}{assert} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{SOUTH}\PYG{p}{,} \PYG{n}{Direction}\PYG{p}{)}

\PYG{n}{thing} \PYG{o}{=} \PYG{n+nb}{object}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{assert} \PYG{n}{thing} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{Direction}
\end{sphinxVerbatim}


\subsection{Iteration}
\label{\detokenize{enums:iteration}}
\sphinxAtStartPar
The members of an enum type can be iterated over with the operator
\sphinxstyleemphasis{in}. The order in which the members are provided by the iterator is
the order of definition.
\sphinxSetupCaptionForVerbatim{Iterate over enum members:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id5}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{members} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{member} \PYG{o+ow}{in} \PYG{n}{Direction}\PYG{p}{:}
    \PYG{n}{members}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{member}\PYG{p}{)}

\PYG{k}{assert} \PYG{n}{members} \PYG{o}{==} \PYG{p}{[}\PYG{n}{NORTH}\PYG{p}{,} \PYG{n}{EAST}\PYG{p}{,} \PYG{n}{SOUTH}\PYG{p}{,} \PYG{n}{WEST}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
An iterator can also be explicitely obtained using the property
\sphinxcode{\sphinxupquote{member}}.
\sphinxSetupCaptionForVerbatim{Iterate over enum members with the property ‘members’:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id6}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{members} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{member} \PYG{o+ow}{in} \PYG{n}{Direction}\PYG{o}{.}\PYG{n}{members}\PYG{p}{:}
    \PYG{n}{members}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{member}\PYG{p}{)}

\PYG{k}{assert} \PYG{n}{members} \PYG{o}{==} \PYG{p}{[}\PYG{n}{NORTH}\PYG{p}{,} \PYG{n}{EAST}\PYG{p}{,} \PYG{n}{SOUTH}\PYG{p}{,} \PYG{n}{WEST}\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Sort order}
\label{\detokenize{enums:sort-order}}\sphinxSetupCaptionForVerbatim{Default ordering:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id7}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{NORTH} \PYG{o}{\PYGZlt{}} \PYG{n}{SOUTH}
\PYG{k}{assert} \PYG{o+ow}{not} \PYG{n}{NORTH} \PYG{o}{\PYGZgt{}} \PYG{n}{SOUTH}
\PYG{k}{assert} \PYG{n}{EAST}  \PYG{o}{\PYGZgt{}} \PYG{n}{NORTH}
\PYG{k}{assert} \PYG{o+ow}{not} \PYG{n}{EAST} \PYG{o}{\PYGZlt{}} \PYG{n}{NORTH}
\PYG{k}{assert} \PYG{n}{EAST} \PYG{o}{!=} \PYG{n}{NORTH}
\end{sphinxVerbatim}


\subsection{Conversion to and from numbers}
\label{\detokenize{enums:conversion-to-and-from-numbers}}\sphinxSetupCaptionForVerbatim{Conversion to and from numbers:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id8}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{SOUTH}\PYG{o}{.}\PYG{n}{ord} \PYG{o}{==} \PYG{l+m+mi}{2}
\PYG{k}{assert} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{SOUTH}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{2}
\PYG{k}{assert} \PYG{n}{Direction}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{SOUTH}
\PYG{k}{assert} \PYG{n}{Direction}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o+ow}{is} \PYG{n}{SOUTH}
\end{sphinxVerbatim}


\subsection{Conversion to and from strings}
\label{\detokenize{enums:conversion-to-and-from-strings}}\sphinxSetupCaptionForVerbatim{Conversion to and from strings:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id9}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{SOUTH}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SOUTH}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{assert} \PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{SOUTH}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SOUTH}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{assert} \PYG{n}{Direction}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SOUTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{SOUTH}
\PYG{k}{assert} \PYG{n}{Direction}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SOUTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o+ow}{is} \PYG{n}{SOUTH}
\end{sphinxVerbatim}


\subsection{Explicitely specifying \sphinxtitleref{ord}}
\label{\detokenize{enums:explicitely-specifying-ord}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ord()}} can be overridden in the default constructor with the
keyword argument \sphinxcode{\sphinxupquote{ord}}. It is possible to provide an own
constructor, but it then should be considered whether and how to pass
on \sphinxcode{\sphinxupquote{ord}} to the super class {\hyperref[\detokenize{enums:greenland.base.enums.Enum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Enum}}}}}.
\sphinxSetupCaptionForVerbatim{Explicitely specifying ord:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id10}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Quartett}\PYG{p}{(}\PYG{n}{Enum}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}

\PYG{n}{ONE} \PYG{o}{=} \PYG{n}{Quartett}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ONE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{} automatic ord = 0}
\PYG{n}{TWO} \PYG{o}{=} \PYG{n}{Quartett}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TWO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{ord} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{THREE} \PYG{o}{=} \PYG{n}{Quartett}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{THREE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}            \PYG{c+c1}{\PYGZsh{} automatic ord = 101}
\PYG{n}{FOUR} \PYG{o}{=} \PYG{n}{Quartett}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FOUR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{ord} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{)}

\PYG{n}{Quartett}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{n+nb}{locals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Those members where \sphinxcode{\sphinxupquote{ord}} is specified get the desired
\sphinxcode{\sphinxupquote{ord}}, but will raise an assertion if the ord value already
exists. Where no \sphinxcode{\sphinxupquote{ord}} is specified, an \sphinxcode{\sphinxupquote{ord}} value (one)
larger than all \sphinxcode{\sphinxupquote{ord}} values of the members existing so far
is chosen automatically. This algorithm has the advantage of
preserving the definition order in the sort order as far as possible,
but avoids unwelcome surprises.
\sphinxSetupCaptionForVerbatim{Overridden ord values:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id11}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{ONE}\PYG{o}{.}\PYG{n}{ord} \PYG{o}{==} \PYG{l+m+mi}{0}
\PYG{k}{assert} \PYG{n}{TWO}\PYG{o}{.}\PYG{n}{ord} \PYG{o}{==} \PYG{l+m+mi}{100}
\PYG{k}{assert} \PYG{n}{THREE}\PYG{o}{.}\PYG{n}{ord} \PYG{o}{==} \PYG{l+m+mi}{101}
\PYG{k}{assert} \PYG{n}{FOUR}\PYG{o}{.}\PYG{n}{ord} \PYG{o}{==} \PYG{l+m+mi}{50}
\end{sphinxVerbatim}

\sphinxAtStartPar
The sort order is defined by the \sphinxcode{\sphinxupquote{ord}} attribute of the enum
members.
\sphinxSetupCaptionForVerbatim{Sort order when overriding ord:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id12}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{FOUR} \PYG{o}{\PYGZlt{}} \PYG{n}{THREE}
\PYG{k}{assert} \PYG{n}{FOUR} \PYG{o}{\PYGZlt{}} \PYG{n}{TWO}
\end{sphinxVerbatim}

\sphinxAtStartPar
Whereas the iteration order is always the order in which the members where defined.
\sphinxSetupCaptionForVerbatim{Unchanged iteration order when overriding ord:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id13}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Quartett}\PYG{o}{.}\PYG{n}{members}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}
    \PYG{n}{ONE}\PYG{p}{,} \PYG{n}{TWO}\PYG{p}{,} \PYG{n}{THREE}\PYG{p}{,} \PYG{n}{FOUR}
\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{Attributes}
\label{\detokenize{enums:attributes}}
\sphinxAtStartPar
(TBD)


\subsection{Typing}
\label{\detokenize{enums:typing}}
\sphinxAtStartPar
(TBD)
\sphinxSetupCaptionForVerbatim{Typed function example:}
\def\sphinxLiteralBlockLabel{\label{\detokenize{enums:id14}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}direction}\PYG{p}{(}\PYG{n}{d}\PYG{p}{:} \PYG{n}{Direction}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}


\PYG{n}{print\PYGZus{}direction}\PYG{p}{(}\PYG{n}{NORTH}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Example(s)}
\label{\detokenize{enums:example-s}}
\sphinxAtStartPar
The complete code examples can be found in the file \sphinxstyleemphasis{enums\sphinxhyphen{}example.py}
in the doc distribution archive or in \sphinxcode{\sphinxupquote{doc/\_build/tangle}} after
building the documentation with \sphinxcode{\sphinxupquote{make tangle}}.


\section{Comparison to built\sphinxhyphen{}in enum}
\label{\detokenize{enums:comparison-to-built-in-enum}}\begin{itemize}
\item {} 
\sphinxAtStartPar
TBD: More complicated

\item {} 
\sphinxAtStartPar
TBD: Only a single construction parameter

\end{itemize}


\section{Design decisions and alternatives}
\label{\detokenize{enums:design-decisions-and-alternatives}}
\sphinxAtStartPar
(TBD)


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{g}
\item\relax\sphinxstyleindexentry{greenland.base.enums}\sphinxstyleindexpageref{enums:\detokenize{module-greenland.base.enums}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}