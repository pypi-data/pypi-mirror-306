from data_generation_tool.constraints.column_constraints import Allowed, Forbidden, MinSize, MaxSize, SizeInterval, By
from data_generation_tool.errors import UnsatisfiableConstraints
from data_generation_tool.generators import ColumnGenerator
from data_generation_tool.requests import ColumnGenerationRequest


class SeriesGenerator(ColumnGenerator):
    """
    Generator for series columns.
    """

    def generate(self, column: ColumnGenerationRequest, count: int) -> list:
        """
        Generates a list of series based on the constraints provided in the column request.

        Parameters
        ----------
        column : ColumnGenerationRequest
            The request for generating the given column : contains the constraints
        count : int
            The number of values to return
        category : str
            The category of series to generate

        Returns
        -------
        list
            The data generated

        Raises
        -------
            ValueError
                If the expected type in the column does not match the type of values generated by the generator.

            UnsatisfiableConstraints
                If the given set of constraints are not satisfiable.
        """

        allowed_series = [series for series_list in _series_by_category.values() for series in series_list]
        forbidden_series = []
        min_size = None
        max_size = None

        for constraint in column.constraints:
            if isinstance(constraint, By):
                if constraint.criterion.lower() == "category":
                    category = constraint.value
                    if category not in _series_by_category:
                        raise ValueError(f"Category {category} is not recognized.")
                    series = _series_by_category[category]
                    allowed_series = series


            elif isinstance(constraint, Allowed):
                allowed_series = [s for s in allowed_series if s in constraint.value]
            elif isinstance(constraint, Forbidden):
                forbidden_series = constraint.value
            elif isinstance(constraint, MinSize):
                min_size = constraint.value
            elif isinstance(constraint, MaxSize):
                max_size = constraint.value
            elif isinstance(constraint, SizeInterval):
                min_size = constraint.lower_bound
                max_size = constraint.upper_bound

        allowed_series = [s for s in allowed_series if s not in forbidden_series]

        if min_size is not None:
            allowed_series = [s for s in allowed_series if len(s) >= min_size]

        if max_size is not None:
            allowed_series = [s for s in allowed_series if len(s) <= max_size]

        if not allowed_series:
            raise UnsatisfiableConstraints("The constraints are unsatisfiable.")

        return self.post_processing(self.rng.choice(allowed_series, count), column.constraints)


_series_by_category = {
    "Drama": ["Breaking Bad", "Game of Thrones", "The Crown", "Stranger Things", "The Mandalorian"],
    "Comedy": ["Friends", "The Office", "Brooklyn Nine-Nine", "Parks and Recreation", "The Big Bang Theory"],
    "Sci-Fi": ["Black Mirror", "Westworld", "The Expanse", "Doctor Who", "Star Trek: The Next Generation"],
    "Fantasy": ["The Witcher", "The Lord of the Rings", "His Dark Materials", "Avatar: The Last Airbender",
                "Shadow and Bone"],
    "Crime": ["Sherlock", "Mindhunter", "Narcos", "True Detective", "Peaky Blinders"],
    "Thriller": ["Stranger Things", "Dark", "Mindhunter", "Sherlock", "Dexter"],
    "Action": ["The Mandalorian", "The Umbrella Academy", "The Boys", "Arrow", "Daredevil"],
    "Adventure": ["Stranger Things", "The Witcher", "The Mandalorian", "Doctor Who", "Lost in Space"],
    "Animation": ["Rick and Morty", "Avatar: The Last Airbender", "BoJack Horseman", "The Simpsons", "Futurama"],
    "Family": ["Stranger Things", "The Mandalorian", "The Umbrella Academy", "Lost in Space", "Doctor Who"]
}
