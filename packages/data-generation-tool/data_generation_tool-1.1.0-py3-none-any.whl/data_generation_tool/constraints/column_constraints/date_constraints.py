from datetime import datetime, date
from typing import Union

from data_generation_tool.constraints.column_constraints import ColumnConstraint
from data_generation_tool.types import Date
from data_generation_tool.utils import DateIncrementUnit, DateFormatType


class DateConstraint(ColumnConstraint):
    """
    Base class for constraints that are related to numeric values
    """

    def target_column_type(self) -> type:
        return Date


class Future(DateConstraint):
    """
    Indicate that the dates generated in the column should be in the future
    """


class Past(DateConstraint):
    """
    Indicate that the dates generated in the column should be in the past
    """


class After(DateConstraint):
    """
    Indicate that the dates generated in the column should occur after a given date

    Attributes
    ----------
        value: datetime
            The minimum date allowed in the column
    """

    def __init__(self, value: Union[date, datetime]):
        if isinstance(value, date):
            self.value = datetime.combine(value, datetime.min.time())
        else:
            self.value = value


class Before(DateConstraint):
    """
    Indicate that the dates generated in the column should occur before a given date

    Attributes
    ----------
        value: datetime
            The maximum date allowed in the column
    """

    def __init__(self, value: Union[date, datetime]):
        if isinstance(value, date):
            self.value = datetime.combine(value, datetime.min.time())
        else:
            self.value = value


class Period(DateConstraint):
    """
    Indicate that the dates generated in the column should be between two given dates

    Attributes
    ----------
        lower_bound: datetime
            The minimum date allowed in the column
        upper_bound: datetime
            The maximum date allowed in the column

    Raises
    -------
        ValueError
            If `lower_bound` occurs before `upper_bound`.
    """

    def __init__(self, lower_bound: Union[date, datetime], upper_bound: Union[date, datetime]):
        if isinstance(lower_bound, date) and not isinstance(lower_bound, datetime):
            lower_bound = datetime.combine(lower_bound, datetime.min.time())
        if isinstance(upper_bound, date) and not isinstance(upper_bound, datetime):
            upper_bound = datetime.combine(upper_bound, datetime.min.time())

        if lower_bound > upper_bound:
            raise ValueError("lower_bound must precede upper_bound")

        if isinstance(lower_bound, date):
            self.lower_bound = datetime.combine(lower_bound, datetime.min.time())
        else:
            self.lower_bound = lower_bound

        if isinstance(upper_bound, date):
            self.upper_bound = datetime.combine(upper_bound, datetime.min.time())
        else:
            self.value = upper_bound


class RandomDate(DateConstraint):
    """
    Placeholder class to indicate that the dates should be generated randomly
    """
    pass


class IncrementalDate(DateConstraint):
    """
    Indicate that the dates should be generated by increment following a given step and unit

    Attributes
    ----------
        unit: DateIncrementUnit
            The unit for incrementing the date
        step: int
            The step for incrementing the dates
    """

    def __init__(self, unit: DateIncrementUnit = DateIncrementUnit.DAY, step: int = 1):
        self.unit = unit
        self.step = step


class DateFormat(DateConstraint):
    """
    The format followed by the generated dates

    Attributes
    ----------
        value: DateFormatType
            How the date will be formatted
    """

    def __init__(self, value: DateFormatType):
        self.value = value
