from data_generation_tool.constraints.column_constraints import Allowed, Forbidden, MinSize, MaxSize, SizeInterval, By
from data_generation_tool.errors import UnsatisfiableConstraints
from data_generation_tool.generators import ColumnGenerator
from data_generation_tool.requests import ColumnGenerationRequest


class BrandGenerator(ColumnGenerator):
    """
    Generator for brand columns.
    """

    def generate(self, column: ColumnGenerationRequest, count: int) -> list:
        """
        Generates a list of brands based on the constraints provided in the column request.

        Parameters
        ----------
        column : ColumnGenerationRequest
            The request for generating the given column : contains the constraints
        count : int
            The number of values to return

        Returns
        -------
        list
            The data generated

        Raises
        -------
        ValueError
            If the expected type in the column does not match the type of values generated by the generator.

        UnsatisfiableConstraints
            If the given set of constraints are not satisfiable.
        """
        allowed_brands = [brand for continent_brands in _brands_by_continent.values()
                          for category_brands in continent_brands.values()
                          for brand in category_brands]
        forbidden_brands = []
        min_size = None
        max_size = None
        continent = None
        category = None

        for constraint in column.constraints:
            if isinstance(constraint, Allowed):
                allowed_brands = [brand for brand in allowed_brands if brand in constraint.value]
            elif isinstance(constraint, Forbidden):
                forbidden_brands.extend(constraint.value)
            elif isinstance(constraint, MinSize):
                min_size = constraint.value
            elif isinstance(constraint, MaxSize):
                max_size = constraint.value
            elif isinstance(constraint, SizeInterval):
                min_size = constraint.lower_bound
                max_size = constraint.upper_bound
            elif isinstance(constraint, By):
                if constraint.criterion.lower() == "category":
                    category = constraint.value
                    if continent is not None and category not in _brands_by_continent[continent]:
                        raise ValueError(f"Category {category} is not recognized.")
                    elif not any(category in categories for categories in _brands_by_continent.values()):
                        raise ValueError(f"Category {category} is not recognized.")

                elif constraint.criterion.lower() == "continent":
                    continent = constraint.value
                    if continent not in _brands_by_continent:
                        raise ValueError(f"Continent {continent} is not recognized.")

        if continent:
            if category:
                if category not in _brands_by_continent[continent]:
                    raise ValueError(f"Category {category} is not recognized for continent {continent}.")
                allowed_brands = _brands_by_continent[continent][category]
            else:
                allowed_brands = [brand for category_brands in _brands_by_continent[continent].values()
                                  for brand in category_brands]
        elif category:
            if not any(category in continent_brands for continent_brands in _brands_by_continent.values()):
                raise ValueError(f"Category {category} is not recognized.")
            allowed_brands = [brand for continent_brands in _brands_by_continent.values()
                              if category in continent_brands
                              for brand in continent_brands[category]]

        allowed_brands = [brand for brand in allowed_brands if brand not in forbidden_brands]

        if min_size is not None:
            allowed_brands = [brand for brand in allowed_brands if len(brand) >= min_size]

        if max_size is not None:
            allowed_brands = [brand for brand in allowed_brands if len(brand) <= max_size]

        if not allowed_brands:
            raise UnsatisfiableConstraints("The constraints are unsatisfiable.")

        return self.post_processing(self.rng.choice(allowed_brands, count), column.constraints)


# Dictionary of brands by continent and category
_brands_by_continent = {
    "Africa": {
        "Technology": ["MTN", "Safaricom", "Dangote", "M-Pesa"],
        "Automobile": ["Innoson", "Kantanka", "Mobius"],
        "Consumer Goods": ["Unilever", "PZ Cussons", "Nando's"]
    },
    "Asia": {
        "Technology": ["Samsung", "Huawei", "Sony", "LG"],
        "Automobile": ["Toyota", "Honda", "Hyundai", "Nissan"],
        "Consumer Goods": ["Samsung Electronics", "LG Electronics", "Panasonic"]
    },
    "Europe": {
        "Technology": ["BMW", "Siemens", "Nokia", "Philips"],
        "Automobile": ["Volkswagen", "Mercedes-Benz", "BMW"],
        "Consumer Goods": ["Unilever", "Nestle", "L'Oreal"]
    },
    "North America": {
        "Technology": ["Apple", "Google", "Microsoft", "Amazon"],
        "Automobile": ["Ford", "General Motors", "Tesla", "Chrysler"],
        "Consumer Goods": ["Coca-Cola", "PepsiCo", "Procter & Gamble"]
    },
    "South America": {
        "Technology": ["MercadoLibre", "Tencent", "TikTok", "Despegar"],
        "Automobile": ["Volkswagen", "General Motors", "Toyota", "Fiat"],
        "Consumer Goods": ["Natura", "Ambev", "Boticario"]
    },
    "Australia": {
        "Technology": ["Atlassian", "Canva", "Afterpay", "WiseTech Global"],
        "Automobile": ["Holden", "Ford Australia", "Toyota Australia"],
        "Consumer Goods": ["Coles", "Woolworths", "Bunnings Warehouse"]
    },
    "Antarctica": {
        "Technology": ["IceCorp", "PenguinWare", "FreezeTech"],
        "Automobile": ["Polaris", "Snowmobiles"],
        "Consumer Goods": ["Penguin Apparel", "Ice Cream Antarctica"]
    }
}
