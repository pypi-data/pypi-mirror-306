from data_generation_tool.constraints.column_constraints import Allowed, Forbidden, MinSize, MaxSize, SizeInterval, By
from data_generation_tool.errors import UnsatisfiableConstraints
from data_generation_tool.generators import ColumnGenerator
from data_generation_tool.requests import ColumnGenerationRequest


class MealGenerator(ColumnGenerator):
    """
    Generator for meal columns.
    """

    def generate(self, column: ColumnGenerationRequest, count: int) -> list:
        """
        Generates a list of meals based on the constraints provided in the column request.

        Parameters
        ----------
        column : ColumnGenerationRequest
            The request for generating the given column : contains the constraints
        count : int
            The number of values to return

        Returns
        -------
        list
            The data generated

        Raises
        -------
        ValueError
            If the expected type in the column does not match the type of values generated by the generator.

        UnsatisfiableConstraints
            If the given set of constraints are not satisfiable.
        """

        allowed_meals = [meal for meal_list in _meals.values() for meal in meal_list]
        forbidden_meals = []
        min_size = None
        max_size = None

        for constraint in column.constraints:
            if isinstance(constraint, By):
                if constraint.criterion.lower() == "continent":
                    continent = constraint.value
                    if continent not in _meals:
                        raise ValueError(f"Continent {continent} is not recognized.")
                    available_meals = _meals[continent]
                    allowed_meals = available_meals  # Reset allowed_meals to match available_meals
            elif isinstance(constraint, Allowed):
                allowed_meals = [meal for meal in allowed_meals if meal in constraint.value]
            elif isinstance(constraint, Forbidden):
                forbidden_meals.extend(constraint.value)
            elif isinstance(constraint, MinSize):
                min_size = constraint.value
            elif isinstance(constraint, MaxSize):
                max_size = constraint.value
            elif isinstance(constraint, SizeInterval):
                min_size = constraint.lower_bound
                max_size = constraint.upper_bound

        allowed_meals = [meal for meal in allowed_meals if meal not in forbidden_meals]

        if min_size is not None:
            allowed_meals = [meal for meal in allowed_meals if len(meal) >= min_size]

        if max_size is not None:
            allowed_meals = [meal for meal in allowed_meals if len(meal) <= max_size]

        if not allowed_meals:
            raise UnsatisfiableConstraints("The constraints are unsatisfiable.")

        return self.post_processing(self.rng.choice(allowed_meals, count), column.constraints)


_meals = {
    "Africa": ["Jollof Rice", "Bunny Chow", "Piri Piri Chicken", "Tagine", "Injera"],
    "Asia": ["Sushi", "Pad Thai", "Kimchi", "Biryani", "Peking Duck"],
    "Europe": ["Pizza", "Paella", "Croissant", "Goulash", "Moussaka"],
    "North America": ["Burger", "BBQ Ribs", "Poutine", "Tacos", "Clam Chowder"],
    "South America": ["Feijoada", "Empanadas", "Arepas", "Ceviche", "Asado"],
    "Australia": ["Vegemite Toast", "Meat Pie", "Barramundi", "Pavlova", "Lamington"],
}
