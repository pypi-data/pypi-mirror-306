import amsdal_glue as glue
from _typeshed import Incomplete
from amsdal_data.connections.constants import METADATA_KEY as METADATA_KEY, METADATA_TABLE as METADATA_TABLE, OBJECT_ID as OBJECT_ID, OBJECT_VERSION as OBJECT_VERSION, PRIMARY_PARTITION_KEY as PRIMARY_PARTITION_KEY, REFERENCE_TABLE as REFERENCE_TABLE, SECONDARY_PARTITION_KEY as SECONDARY_PARTITION_KEY, TRANSACTION_TABLE as TRANSACTION_TABLE
from amsdal_data.connections.historical.data_query_transform import METADATA_TABLE_ALIAS as METADATA_TABLE_ALIAS, NEXT_VERSION_FIELD as NEXT_VERSION_FIELD
from amsdal_data.connections.historical.schema_version_manager import HistoricalSchemaVersionManager as HistoricalSchemaVersionManager
from amsdal_data.connections.historical.table_name_transform import TableNameTransform as TableNameTransform
from amsdal_data.connections.postgresql_historical import PostgresHistoricalConnection as PostgresHistoricalConnection
from amsdal_data.connections.sqlite_historical import SqliteHistoricalConnection as SqliteHistoricalConnection
from amsdal_glue_core.common.operations.mutations.data import DataMutation as DataMutation
from amsdal_utils.models.data_models.address import Address as Address
from collections.abc import Sequence
from typing import Any

class DataMutationTransform:
    connection: Incomplete
    mutation: Incomplete
    _data: Incomplete
    def __init__(self, connection: SqliteHistoricalConnection | PostgresHistoricalConnection, mutation: DataMutation) -> None: ...
    @property
    def is_internal_tables(self) -> bool: ...
    @property
    def data(self) -> list[glue.Data] | None: ...
    def transform(self) -> Sequence[DataMutation]: ...
    def _transform_insert_data(self, mutation: glue.InsertData) -> Sequence[DataMutation]: ...
    def _transform_update_data(self, mutation: glue.UpdateData) -> Sequence[DataMutation]: ...
    def _transform_delete_data(self, mutation: glue.DeleteData) -> Sequence[DataMutation]: ...
    def _process_data(self, schema_reference: glue.SchemaReference, data: list[glue.Data], *, is_insert: bool = False, mark_as_deleted: bool = False) -> None: ...
    @classmethod
    def _build_insert_mutations(cls, schema: glue.SchemaReference, data: list[glue.Data]) -> Sequence[glue.InsertData]: ...
    def _resolve_current_version(self, schema_reference: glue.SchemaReference, object_id: str) -> str | None: ...
    @classmethod
    def _generate_references(cls, address: Address, data: Any, reference_buffer: list[glue.Data]) -> None: ...
    @staticmethod
    def _is_reference(data: Any) -> bool: ...
