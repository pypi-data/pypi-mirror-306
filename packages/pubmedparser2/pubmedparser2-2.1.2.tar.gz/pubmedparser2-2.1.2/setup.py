# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pubmedparser']

package_data = \
{'': ['*']}

install_requires = \
['appdirs>=1.4.4,<2.0.0', 'psutil>=6.1.0,<7.0.0']

setup_kwargs = {
    'name': 'pubmedparser2',
    'version': '2.1.2',
    'description': 'Download and parse pubmed publication data',
    'long_description': '![PyPI - Version](https://img.shields.io/pypi/v/pubmedparser2)\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/pubmedparser2)\n\nRead XML files and pull out selected values. Values to collect are\ndetermined by paths found in a [structure file](#structure-file). The\nstructure file also includes a key which associates the values with a\nparent element and names, which determine which file to place the\nelements in.\n\nFiles can be passed as either gzipped or uncompressed XML files or from\nstandard in.\n\nFor more info on Pubmed\'s XML files see:\n[pubmed\\_190101\\_.dtd.](https://dtd.nlm.nih.gov/ncbi/pubmed/doc/out/190101/index.html)\n\nUsage:\n\n``` python\nimport pubmedparser\nimport pubmedparser.ftp\n\n# Download data\nfiles = pubmedparser.ftp.download(range(1, 6))\n\n# Read XML files using a YAML file to describe what data to collect.\ndata_dir = "file_example"\nstructure_file = "example/structure.yml"\nresults = pubmedparser.read_xml(files, structure_file, data_dir)\n```\n\nSee [the example\nfile](https://github.com/net-synergy/pubmedparser/blob/master/example/creating_graphs.py)\nfor more options.\n\nIn python, the structure file can be replaced with a dictionary of\ndictionaries as well.\n\nOr, as a CLI:\n\n``` bash\nxml_read --cache-dir=cache --structure-file=structure.yml \\\n    data/*.xml.gz\n```\n\n## Installing with pip\n\n``` bash\npip install pubmedparser2\n```\n\n## Building python package\n\nRequires `zlib`.\n\nClone the repository and cd into the directory. Then use [poetry](https://python-poetry.org/docs) to build and install the package.\n\n``` bash\nmake python\n```\n\n# Structure file\n\nThe structure file is a YAML file containing key-value pairs for\ndifferent tags and paths. There are two required keys: `root` and `key`.\n`Root` provide the top-level tag, in the case of the pubmed files this\nwill be `PubmedArticleSet`.\n\n``` bash\nroot: "/PubmedArticleSet"\n```\n\nThe `/` is not strictly required as the program will ignore them, but\nthey are used to conform to the\n[xpath](https://en.wikipedia.org/wiki/XPath) syntax (although this\nprogram does not handle all cases for `xpath`).\n\nOnly tags below the root tag will be considered and the parsing will\nterminate once the program has left the root of the tree.\n\n`Key` is a reference tag. In the pubmed case, all data is with respect\nto a publication, so the key should identify the publication the values\nare linked to. The `PMID` tag is a suitable candidate.\n\n``` bash\nkey: "/PubmedArticle/MedlineCitation/PMID"\n```\n\nAfter `root`, all paths are taken as relative to the root node.\n\nThe other name-pairs in the file determine what other items to collect.\nThese can either be a simple name and path, like the key, such as:\n\n``` bash\nLanguage: "/PubmedArticle/MedlineCitation/Article/Language"\nKeywords: "/PubmedArticle/MedlineCitation/KeywordList/Keyword"\n```\n\nOr they can use a hierarchical representation to get multiple values\nbelow a child. This is mainly used to handle lists of items where there\nis an indefinite number of items below the list.\n\n``` bash\nAuthor: {\n  root: "/PubmedArticle/MedlineCitation/Article/AuthorList",\n  key: "/Author/auto_index",\n  LastName: "/Author/LastName",\n  ForeName: "/Author/ForeName",\n  Affiliation: "/Author/AffiliationInfo/Affiliation",\n  Orcid: "/Author/Identifier/[@Source=\'ORCID\']"\n}\n```\n\nHere, all paths are relative to the sub-structures `root` path, which is\nin turn relative to the parent structure\'s `root`. This sub-structure\nuses the same rules as the parent structure, so it needs both a `root`\nand `key` name-value pair. The results of searching each path are\nwritten to separate files. Each file gets a column for the parent and\nchild key. So in this case, each element of the author is linked by an\nauthor key and that is related to the publication they authored through\nthe parent key.\n\nThe main parser is called recursively to parse this structure so it\'s\nworth thinking about what the root should be under the context that the\nparser will be called with that root. This means if, instead of stopping\nat `/AuthorList`, `/Author` was added to the end of the root, the parser\nwould be called for each individual author, instead of once per author\nlist, leading to all author\'s getting the index 0.\n\nThere are a number of additional syntax constructs to note in the above\nexample. The key uses the special name `auto_index`, since there is no\nauthor ID in the XML data, an index is used to count the authors in the\norder they appear. This resets for each publication and starts at 0.\nTreating the `auto_index` as the tail of a path allows you to control\nwhen the indexing occursâ€”the index is incremented whenever it hits a\n`/Author` tag.\n\nIn addition to the `auto_index` key, there is a second special index\nname, `condensed`.\n\n``` bash\nReference: {\n  root: "/PubmedArticle/PubmedData/ReferenceList/Reference/ArticleIdList"\n  key: "/condensed"\n  PMID: "/ArticleId/[@IdType=\'pubmed\']"\n  DOI: "/ArticleId/[@IdType=\'doi\']"\n}\n```\n\nIn the case of `condensed`, instead of writing the results to separate\nfiles, they will printed as columns in the same file, and therefore do\nnot need an additional key for the sub-structure. If any of the elements\nare missing, they will be left blank, for example, if the parser does\nnot find a pubmed ID for a given reference, the row will look like\n`"%s\\t\\t%s"` where the first string will contain the parent key (the\n`PMID` of the publication citing this reference) and the second string\nwill contain the reference\'s `DOI`.\n\nThe `/[@attribute=\'value\']` syntax at the end of a path tells the parser\nto only collect an element if it has an attribute and the attribute\'s\nvalue matches the supplied value. Similarly the `/@attribute` syntax,\ntells the parser to collect the value of the attribute `attribute` along\nwith the element\'s value. Then both values will be written to the output\nfile. Currently only a single attribute can be specified.\n\nLastly, there is a special syntax for writing condensed sub-structures:\n\n``` bash\nDate: "/PubmedArticle/MedlineCitation/Article/Journal/JournalIssue/PubDate/{Year,Month,Day}"\n```\n\nThe `{child,child,child}` syntax allows you to select multiple children\nat the same level to be printed to a single file. This is useful when\nmultiple children make up a single piece of information (i.e. the\npublication date).\n\nA similar example structure file can be found in the example directory\nof this project at:\n[file:./example/structure.yml](./example/structure.yml).\n\n# Structure dictionary\n\nThe structure of the xml data to read can also be described as a python\ndictionary of dictionaries.\n\nThe form is similar to the file:\n\n``` python\nstructure = {\n    "root": "//PubmedArticleSet",\n    "key": "/PubmedArticle/MedlineCitation/PMID",\n    "DOI": "/PubmedArticle/PubmedData/ArticleIdList/ArticleId/[@IdType=\'doi\']",\n    "Date": "/PubmedArticle/MedlineCitation/Article/Journal/JournalIssue/PubDate/{Year,Month,Day}",\n    "Journal": "/PubmedArticle/MedlineCitation/Article/Journal/{Title,ISOAbbreviation}",\n    "Language": "/PubmedArticle/MedlineCitation/Article/Language",\n    "Author": {\n        "root": "/PubmedArticle/MedlineCitation/Article/AuthorList",\n        "key": "/Author/auto_index",\n        "LastName": "/Author/LastName",\n        "ForName": "/Author/ForeName",\n        "Affiliation": "/Author/AffiliationInfo/Affiliation",\n        "Orcid": "/Author/Identifier/[@Source=\'ORCID\']",\n    },\n    "Grant": {\n        "root": "/PubmedArticle/MedlineCitation/Article/GrantList",\n        "key": "/Grant/auto_index",\n        "ID": "/Grant/GrantID",\n        "Agency": "/Grant/Agency",\n    },\n    "Chemical": "/PubmedArticle/MedlineCitation/ChemicalList/Chemical/NameOfSubstance/@UI",\n    "Qualifier": "/PubmedArticle/MedlineCitation/MeshHeadingList/MeshHeading/QualifierName/@UI",\n    "Descriptor": "/PubmedArticle/MedlineCitation/MeshHeadingList/MeshHeading/DescriptorName/@UI",\n    "Keywords": "/PubmedArticle/MedlineCitation/KeywordList/Keyword",\n    "Reference": {\n        "root": (\n            "/PubmedArticle/PubmedData/ReferenceList/Reference/ArticleIdList"\n        ),\n        "key": "/condensed",\n        "PMID": "/ArticleId/[@IdType=\'pubmed\']",\n        "DOI": "/ArticleId/[@IdType=\'doi\']",\n    },\n}\n```\n\nThis can then be passed to `pubmedparser.read_xml` in place of the\nstructure file.\n',
    'author': 'David Connell',
    'author_email': 'davidconnell12@gmail.com',
    'maintainer': 'David Connell',
    'maintainer_email': 'davidconnell12@gmail.com',
    'url': 'https://github.com/net-synergy/pubmedparser',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}
from build_script import *
build(setup_kwargs)

setup(**setup_kwargs)
