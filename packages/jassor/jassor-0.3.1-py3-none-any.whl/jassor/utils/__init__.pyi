import json
import types
from typing import Any, List
from io import TextIOWrapper
from pathlib import Path
from threading import Condition
from typing import TextIO
import numpy as np
import multiprocessing
from typing import TypeVar

class JassorJsonEncoder(json.JSONEncoder):
    def __init__(self, *args, **kwargs) -> None: ...
    def encode(self, obj: Any) -> str: ...
    def iterencode(self, o, _one_shot: bool = False): ...

class IOWrapper:
    def __init__(self, write_func: callable, flush_func: callable, close_func: callable): ...

class Logger:
    STEP: int
    DEBUG: int
    INFO: int
    WARNING: int
    def __init__(self, start: int = 0, indentation: int = 1, file: TextIO | IOWrapper | TextIOWrapper | str | Path = ..., con: Condition = None, level: int = 2) -> None: ...
    def close(self) -> None: ...
    def track(self, message: str, prefix: str = ''): ...
    def step(self, message: str): ...
    def debug(self, message: str): ...
    def info(self, message: str): ...
    def warn(self, message: str): ...
    def tab(self): ...
    def __getitem__(self, item: str): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...

class Merger:
    def __init__(self, temp: np.ndarray | tuple[int, ...], kernel: np.ndarray | tuple[int, ...], dtype: type = ..., steep: float = 4, eps: float = 1e-17) -> None: ...
    @staticmethod
    def get_kernel(shape: tuple[int, ...], steep: float) -> np.ndarray: ...
    def set(self, patch: np.ndarray, grid: tuple[int | None, ...]) -> None: ...
    def tail(self) -> np.ndarray: ...

V = TypeVar('V')

class Process(multiprocessing.Process):
    def __init__(self, target: callable, args=()) -> None: ...
    def start(self) -> None: ...
    def run(self) -> None: ...

class Queue:
    def __init__(self, maxsize: int = 0) -> None: ...
    def ready(self) -> bool: ...
    def is_end(self) -> bool: ...
    def count(self) -> int: ...
    def push(self, item: V) -> None: ...
    def top(self) -> V: ...
    def pop(self) -> V: ...
    def message(self) -> str: ...
    def end(self, flag: bool = False, message: str = '') -> None: ...

class Closed(BaseException):
    def __init__(self, message: str) -> None: ...

class QueueMessageException(BaseException):
    def __init__(self, message: str) -> None: ...
class TimerManager:
    register: dict[str, dict[str, float]]
    def __init__(self, container: str | dict[str, float] = None) -> None: ...
    def __getitem__(self, item: str): ...
    @property
    def costs(self) -> dict[str, float]: ...
    @staticmethod
    def stamp(t: float) -> str: ...
    @staticmethod
    def register_container(key: str, container: dict[str, float]): ...

class Timer:
    def __init__(self, key: str, container: str | dict[str, float]) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: type | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...
    def __call__(self, func: callable): ...

def random_colors(n: int, start: tuple[int, int, int] = (47, 81, 177), step: tuple[int, int, int] = (73, 119, 31), rand: tuple[int, int, int] = (10, 10, 10)) -> list[tuple[int, int, int]]: ...
def random_rainbow_curves(shape: tuple[int, int, int], s: int = 117, k: int = 7, c: int = 50): ...
def plot(item: Any, title: str = None, window_name: str = 'jassor_plot', save_to: str = None, dpi: int = 1000): ...
def plots(items: List[Any], titles: List[str] = None, window_name: str = 'jassor_plot', save_to: str = None, dpi: int = 1000): ...
