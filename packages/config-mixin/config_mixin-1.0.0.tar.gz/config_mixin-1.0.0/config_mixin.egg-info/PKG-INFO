Metadata-Version: 2.1
Name: config_mixin
Version: 1.0.0
Summary: Provide an auto-discovery process for configurations
Author-email: Stephane Robert <stephane.robert@gmail.com>
License: License :: OSI Approved :: Apache Software License
Project-URL: Homepage, https://github.com/stephanerobert/config-mixin
Classifier: Intended Audience :: Developers
Classifier: Development Status :: 4 - Beta
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE.txt
Requires-Dist: munch
Requires-Dist: PyYAML
Provides-Extra: test
Requires-Dist: pytest; extra == "test"
Requires-Dist: pytest-cov; extra == "test"
Requires-Dist: pyhamcrest; extra == "test"

![Build Status](https://github.com/stephanerobert/config-mixin/actions/workflows/tox.yml/badge.svg?branch=master)
[![PyPI version](https://badge.fury.io/py/config-mixin.svg)](http://badge.fury.io/py/config-mixin)


Mission
=======

Provide an auto-discovery process of configurations for simple code use. Given a path and a list of pattern,
the result config will be a shortcut to any config.

## Usage

Setup:

    config = mixin(
        path="path/to/my/files",
        patterns=["path/(*)/file.yaml"]
    )

Use it:

    print config.mynamespace.key

## Parameters

- **path**

    Initial path to configs.  Patterns will be tested against the file structure underneath the path,
    and it will be ignored in determining the namespacing.

- **patterns**

    A list of file paths containing (or not) placeholders "(\*)" o find where the configuration files are located.
    The patterns definition order defines which keys has the priority, the last one being the most relevant.

    Each placeholder in the path will result in a namespace in the resulting config.  So let's say you have a pattern

        dir1/(*)/dir2/(*).yaml

    If this pattern finds the file : "dir1/**ns1**/dir2/**file**.yaml" that contains "key: 'value'", the resulting
    config will be

        config.ns1.file.key == "value"

    now if the pattern was

        dir1/ns1/dir2/file.yaml

    for the same file, the resulting config would simply be

        config.key == "value"

    so you can use placeholders "(\*)" to namespace the resulting config and use "\*" without the parenthesis
    to have a variable path without the namespacing

        dir1/(*)/dir2/*.yaml
        config.ns1.key == "value"

## Mocking the probing

Your unit test can have your code use fake_probe instead to which to give a dict, and it will appear as if it
was just mixed-in. Example:

    config = fake_probe({
        "ns1": {
            "file": {
                "key": "value"
            }
        }
    })
    # then
    config.ns1.file.key == "value"

Contributing
============

Feel free to raise issues and send some pull request, we'll be happy to look at them!
