"""This data helps download the movisens data"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_Nback_Helper.ipynb.

# %% auto 0
__all__ = ['NBackHelper']

# %% ../nbs/03_Nback_Helper.ipynb 3
from .config import Config
from .mov_helper import MovisensHelper
import pandas as pd
import json
from fastcore.foundation import patch
import numpy as np

# %% ../nbs/03_Nback_Helper.ipynb 4
class NBackHelper():
    def __init__(self):
        self.config = Config()
        self.mov_helper = MovisensHelper(update = False)
        self.initial_column = "sushi_game_initial"
        self.ema_column = "sushi_game_ema"
        self.sushi_sequences = self.get_sushi_sequences(Config().get_path("sushi_order_32"))
        self.sushi_practice_sequences = self.get_sushi_sequences(Config().get_path("sushi_order_practice"))

    def get_sushi_sequences(self, order_file):
        with open(order_file, 'r') as d:
            sushi_sequences = json.load(d)
            sushi_sequences['1'] = sushi_sequences.pop('SushiOrdersOneBack')
            sushi_sequences['2'] = sushi_sequences.pop('SushiOrdersTwoBack')
            sushi_sequences['3'] = sushi_sequences.pop('SushiOrdersThreeBack')
            sushi_sequences['4'] = sushi_sequences.pop('SushiOrdersFourBack')
            return sushi_sequences

# %% ../nbs/03_Nback_Helper.ipynb 6
@patch
def get_raw_nback_data(self:NBackHelper):
    initial_nback_data = self.mov_helper.get_form('sushi_game_initial').rename(columns = {'sushi_initial':'sushi'})
    ema_nback_data = self.mov_helper.get_form('sushi_game_ema').rename(columns = {'sushi_ema':'sushi'})
    ema_nback_data = ema_nback_data.rename(columns = {'sushi_ema':'sushi'})
    nback_data = pd.concat([initial_nback_data, ema_nback_data]).sort_values(by=['participant']).reset_index(drop=True).dropna().query("sushi!='skipped'")
    return nback_data

# %% ../nbs/03_Nback_Helper.ipynb 8
@patch
def get_discounting_decisions_for_row(self:NBackHelper, row):    
    data = json.loads(row['sushi'].replace('ContractDecisions"','"ContractDecisions"')[:-1])['ContractDecisions']
    for item in data:
        item.update(item.pop('ChosenContract'))
    # Create a DataFrame
    df = pd.DataFrame(data)
    df['mov_index'] = row.mov_index
    return df


@patch
def get_discounting_decisions(self:NBackHelper):
    nback_raw = self.get_raw_nback_data()
    processed_data = []
    for index, row in nback_raw.iterrows():
        processed_data.append(self.get_discounting_decisions_for_row(row))
    df = pd.concat(processed_data)
    mov = self.mov_helper.get_mov_data(columns = ['participant','trigger_date','sampling_day','session_number'])
    df = mov.merge(df, how='right', right_on='mov_index', left_index=True, validate = 'one_to_many')
    return df

# %% ../nbs/03_Nback_Helper.ipynb 10
@patch
def prepare_sequence(self:NBackHelper, n, index, is_practice):
    sequences = self.sushi_practice_sequences if is_practice else self.sushi_sequences 
    df = pd.DataFrame({'item':sequences[str(n)][index]['order']})
    df['sequence'] = index
    df['difficulty']=n
    df['target'] = (df.item == df.item.shift(n)).astype(int)
    df['is_practice'] = is_practice
    return df
    
@patch
def process_single_nback(self:NBackHelper, n, index, picked_pieces, rts, is_practice):
    sequence_length = len(picked_pieces)
    if ((is_practice == False) and (sequence_length != 32)) or ((is_practice) and (sequence_length != 15)):
        print("Invalid sequence length")
    df = self.prepare_sequence(n, index, is_practice)
    df['picked'] = picked_pieces
    df['rt'] = rts
    df['accuracy'] = (df.target == df.picked).astype(int)
    df['accuracy_target'] = df['accuracy']
    df.loc[df.target==0, 'accuracy_target'] = np.nan
    df['accuracy_non_target'] = df['accuracy']
    df.loc[df.target==1, 'accuracy_non_target'] = np.nan
    return df

@patch
def process_nback_row(self:NBackHelper, row):
    data = row['sushi']
    data = data.replace('ContractDecisions"','"ContractDecisions"')[:-1]
    data = json.loads(data)  
    reward = data['PlayedContract']['Salary']
    no_nbacks = len(data['SushiPlaythroughs'])
    n_back_type = {1: 'ema',
                  5: 'initial',
                  9: 'initial_practice'}[no_nbacks]
    
    processed_nbacks = []
    for index, item in enumerate(data['SushiPlaythroughs']):
        if (n_back_type == 'initial') and (index < 4):
            is_practice = False
            back = index + 1
            phase = 'phase 1'
        elif (n_back_type == 'ema'):
            is_practice = False
            back = data['PlayedContract']['Back']
            phase = 'phase 3'
        elif (n_back_type == 'initial_practice') and (index < 8):
            is_practice = True if index%2==0 else False
            back = [1,1,2,2,3,3,4,4][index]
            phase = 'phase 1'
        elif ((n_back_type == 'initial') and (index == 4)) or ((n_back_type == 'initial_practice') and (index == 8)):
            # At the moment we do not process the fifth round of the initial phase
            pass
        else:
            print("This should not happen")
            print(no_nbacks, index, n_back_type)
            print(item)
        processed_nback = self.process_single_nback(back, item['PlayedSushiIndex'], item['DidSushiPieceGetPicked'], item['SushiPickedTimesInMS'], is_practice)
        processed_nback['phase'] = phase
        processed_nbacks.append(processed_nback)

    df = pd.concat(processed_nbacks)
    df['mov_index'] = row.mov_index
    df['reward'] = float(reward)
    
    return df



@patch
def get_nback_reactions(self:NBackHelper):
    nback_raw = self.get_raw_nback_data()
    processed_data = []
    for index, row in nback_raw.iterrows():
        processed_data.append(self.process_nback_row(row))
    df = pd.concat(processed_data)
    mov = self.mov_helper.get_mov_data(columns = ['participant','trigger_date','sampling_day','session_number'])
    df = mov.merge(df, how='right', right_on='mov_index', left_index=True, validate = 'one_to_many')
    return df
