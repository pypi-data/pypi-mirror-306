# scm/models/security/vulnerability_protection_profiles.py

from typing import List, Optional
from pydantic import (
    BaseModel,
    Field,
    model_validator,
    field_validator,
    ConfigDict,
    RootModel,
)
from enum import Enum
import uuid


# Enums (keep all original enums)
class Severity(str, Enum):
    """Enumeration of severity levels."""

    critical = "critical"
    high = "high"
    medium = "medium"
    low = "low"
    informational = "informational"
    any = "any"


class Category(str, Enum):
    """Enumeration of vulnerability categories."""

    any = "any"
    brute_force = "brute-force"
    code_execution = "code-execution"
    code_obfuscation = "code-obfuscation"
    command_execution = "command-execution"
    dos = "dos"
    exploit_kit = "exploit-kit"
    info_leak = "info-leak"
    insecure_credentials = "insecure-credentials"
    overflow = "overflow"
    phishing = "phishing"
    protocol_anomaly = "protocol-anomaly"
    scan = "scan"
    sql_injection = "sql-injection"


class PacketCapture(str, Enum):
    """Enumeration of packet capture options."""

    disable = "disable"
    single_packet = "single-packet"
    extended_capture = "extended-capture"


class Host(str, Enum):
    """Enumeration of host options."""

    any = "any"
    client = "client"
    server = "server"


class BlockIpTrackBy(str, Enum):
    """Enumeration for block_ip track_by options."""

    source_and_destination = "source-and-destination"
    source = "source"


class TimeAttributeTrackBy(str, Enum):
    """Enumeration for time_attribute track_by options."""

    source = "source"
    destination = "destination"
    source_and_destination = "source-and-destination"


# Component Models (keep all original component models)
class BlockIpAction(BaseModel):
    """Represents the 'block_ip' action with additional properties."""

    track_by: BlockIpTrackBy = Field(..., description="Tracking method")
    duration: int = Field(..., description="Duration in seconds", ge=1, le=3600)


class ActionRequest(RootModel[dict]):
    """
    Represents the 'action' field in rules and threat exceptions for requests.
    Enforces that exactly one action is provided and validates 'block_ip' properties.
    """

    @model_validator(mode="before")
    def check_and_transform_action(cls, values):
        if isinstance(values, str):
            # Convert string to dict
            values = {values: {}}
        elif isinstance(values, dict):
            pass
        else:
            raise ValueError("Invalid action format; must be a string or dict.")

        action_fields = [
            "allow",
            "alert",
            "drop",
            "reset_client",
            "reset_server",
            "reset_both",
            "block_ip",
            "default",
        ]

        provided_actions = [field for field in action_fields if field in values]

        if len(provided_actions) != 1:
            raise ValueError("Exactly one action must be provided in 'action' field.")

        action_name = provided_actions[0]
        action_value = values[action_name]

        if action_name == "block_ip":
            # Validate block_ip properties
            if not isinstance(action_value, dict):
                raise ValueError(
                    "'block_ip' action must be a dict with 'track_by' and 'duration' fields."
                )

            try:
                BlockIpAction(**action_value)
            except Exception as e:
                raise ValueError(f"Invalid 'block_ip' action: {e}")
        else:
            # Other actions should have empty dict as value
            if action_value != {}:
                raise ValueError(
                    f"Action '{action_name}' does not take any parameters."
                )

        return values

    def get_action_name(self) -> str:
        return next(iter(self.root.keys()), "unknown")


class ActionResponse(RootModel[dict]):
    """
    Represents the 'action' field in rules and threat exceptions for responses.
    Accepts empty dictionaries.
    """

    @model_validator(mode="before")
    def check_action(cls, values):
        if isinstance(values, str):
            values = {values: {}}
        elif isinstance(values, dict):
            pass
        else:
            raise ValueError("Invalid action format; must be a string or dict.")

        action_fields = [
            "allow",
            "alert",
            "drop",
            "reset_client",
            "reset_server",
            "reset_both",
            "block_ip",
            "default",
        ]

        provided_actions = [field for field in action_fields if field in values]

        if len(provided_actions) > 1:
            raise ValueError("At most one action must be provided in 'action' field.")

        if provided_actions:
            action_name = provided_actions[0]
            action_value = values[action_name]

            if action_name == "block_ip":
                # Validate block_ip properties
                if not isinstance(action_value, dict):
                    raise ValueError(
                        "'block_ip' action must be a dict with 'track_by' and 'duration' fields."
                    )

                try:
                    BlockIpAction(**action_value)
                except Exception as e:
                    raise ValueError(f"Invalid 'block_ip' action: {e}")
            else:
                # Other actions should have empty dict as value
                if action_value != {}:
                    raise ValueError(
                        f"Action '{action_name}' does not take any parameters."
                    )
        else:
            # Accept empty dicts (no action specified)
            if values != {}:
                raise ValueError("Invalid action format.")

        return values

    def get_action_name(self) -> str:
        return next(iter(self.root.keys()), "unknown")


class TimeAttribute(BaseModel):
    """Represents the 'time_attribute' field in threat exceptions."""

    interval: int = Field(
        ...,
        description="Interval in seconds",
        ge=1,
        le=3600,
    )
    threshold: int = Field(
        ...,
        description="Threshold",
        ge=1,
        le=65535,
    )
    track_by: TimeAttributeTrackBy = Field(
        ...,
        description="Track by",
    )


class ExemptIpEntry(BaseModel):
    """Represents an entry in the 'exempt_ip' list."""

    name: str = Field(..., description="Exempt IP name")


# Rule Models
class RuleBase(BaseModel):
    """Base class for Rule."""

    name: str = Field(..., description="Rule name")
    packet_capture: Optional[PacketCapture] = Field(
        None, description="Packet capture setting"
    )
    severity: Optional[List[Severity]] = Field(None, description="List of severities")
    category: Optional[Category] = Field(None, description="Category")
    cve: Optional[List[str]] = Field(None, description="List of CVEs")
    host: Optional[Host] = Field(None, description="Host")
    vendor_id: Optional[List[str]] = Field(None, description="List of vendor IDs")
    threat_name: Optional[str] = Field(None, description="Threat name")


class RuleRequest(RuleBase):
    """Model for rule in request."""

    action: ActionRequest = Field(..., description="Action for the rule")


class RuleResponse(RuleBase):
    """Model for rule in response."""

    action: ActionResponse = Field(..., description="Action for the rule")


# Threat Exception Models
class ThreatExceptionBase(BaseModel):
    """Base class for ThreatException."""

    name: str = Field(..., description="Threat exception name")
    packet_capture: Optional[PacketCapture] = Field(
        None, description="Packet capture setting"
    )
    exempt_ip: Optional[List[ExemptIpEntry]] = Field(None, description="Exempt IP list")
    time_attribute: Optional[TimeAttribute] = Field(None, description="Time attribute")
    notes: Optional[str] = Field(None, description="Notes")


class ThreatExceptionRequest(ThreatExceptionBase):
    """Model for threat exception in request."""

    action: ActionRequest = Field(..., description="Action for the threat exception")


class ThreatExceptionResponse(ThreatExceptionBase):
    """Model for threat exception in response."""

    action: ActionResponse = Field(..., description="Action for the threat exception")


# Main Models
class VulnerabilityProtectionProfileBase(BaseModel):
    """
    Base model for Vulnerability Protection Profile containing common fields.

    This model serves as the foundation for create, update, and response models,
    containing all shared fields and validation logic.
    """

    model_config = ConfigDict(
        validate_assignment=True,
        arbitrary_types_allowed=True,
        populate_by_name=True,
    )

    name: str = Field(
        ...,
        description="Profile name",
        pattern=r"^[a-zA-Z0-9._-]+$",
    )
    description: Optional[str] = Field(None, description="Description")
    folder: Optional[str] = Field(
        None,
        description="Folder",
        max_length=64,
        pattern=r"^[a-zA-Z\d\-_. ]+$",
    )
    snippet: Optional[str] = Field(
        None,
        description="Snippet",
        max_length=64,
        pattern=r"^[a-zA-Z\d\-_. ]+$",
    )
    device: Optional[str] = Field(
        None,
        description="Device",
        max_length=64,
        pattern=r"^[a-zA-Z\d\-_. ]+$",
    )


class VulnerabilityProtectionProfileCreateModel(VulnerabilityProtectionProfileBase):
    """
    Model for creating a new Vulnerability Protection Profile.
    Inherits from base model and adds required fields for creation.
    """

    rules: List[RuleRequest] = Field(..., description="List of rules")
    threat_exception: Optional[List[ThreatExceptionRequest]] = Field(
        None,
        description="List of threat exceptions",
    )

    @model_validator(mode="after")
    def validate_container(self) -> "VulnerabilityProtectionProfileCreateModel":
        container_fields = ["folder", "snippet", "device"]
        provided = [
            field for field in container_fields if getattr(self, field) is not None
        ]
        if len(provided) != 1:
            raise ValueError(
                "Exactly one of 'folder', 'snippet', or 'device' must be provided."
            )
        return self


class VulnerabilityProtectionProfileResponseModel(VulnerabilityProtectionProfileBase):
    """
    Model for Vulnerability Protection Profile responses.
    Includes all base fields plus the id field.
    """

    id: str = Field(
        ...,
        description="Profile ID",
        examples=["123e4567-e89b-12d3-a456-426655440000"],
    )
    rules: List[RuleResponse] = Field(..., description="List of rules")
    threat_exception: Optional[List[ThreatExceptionResponse]] = Field(
        None,
        description="List of threat exceptions",
    )

    @field_validator("id")
    def validate_id(cls, v):
        try:
            uuid.UUID(v)
        except ValueError:
            raise ValueError("Invalid UUID format for 'id'")
        return v


class VulnerabilityProtectionProfileUpdateModel(VulnerabilityProtectionProfileBase):
    """
    Model for updating an existing Vulnerability Protection Profile.
    All fields are optional to allow partial updates.
    """

    id: str = Field(
        ...,
        description="Profile ID",
        examples=["123e4567-e89b-12d3-a456-426655440000"],
    )
    rules: Optional[List[RuleRequest]] = Field(None, description="List of rules")
    threat_exception: Optional[List[ThreatExceptionRequest]] = Field(
        None,
        description="List of threat exceptions",
    )

    @field_validator("id")
    def validate_id(cls, v):
        try:
            uuid.UUID(v)
        except ValueError:
            raise ValueError("Invalid UUID format for 'id'")
        return v
